
================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget]
LSP: Process Zipper: No serialized zipper, processing string
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:18.1394
 :16.9259
 fun:16.5592
    :12.5815
  :12.2142
                :11.1461
 #:10.8597
     :10.645
   :10.44
        :10.3591
 ?:10.0535
 function:10.0145
 (:9.84977
 func:9.79019
 let:9.77849
            :9.71493
 \:9.69062
 (*:9.59916
      :9.43087
       :9.37281
 {:9.30324

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :18.9067
 :18.266
fun:16.9365
       :14.5592
  :14.5371
 fun:14.0965
	:13.7696
    :13.1474
     :12.8845
func:12.6437
#:12.3044
let:12.2284
           :11.2269

:11.1412
      :11.0295
(*:10.9684
                :10.4029
        :10.04
function:10.0374
 let:9.95281
         :9.87881

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Target types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:21.1768
 let:16.1325
 #:15.513
 (*:13.4133
 rec:12.7272
 fix:11.9184
 func:11.5824
 @:11.4186
 (:11.346
 mem:10.9546
 ~:10.8986
 f:10.7477
 find:10.7389
 ##:10.7016
 //:10.6202
 mut:10.5476
 *:10.5289
 recursive:10.4956
 Rec:10.4779
 match:10.4568
 fol:10.3738

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 widget:16.7855
 root:15.0304
 w:14.2673
 container:13.4533
 tree:12.5651
 node:12.5276
 parent:12.282
 layout:12.0537
 top:11.8056
 x:11.4399
 target:11.2011
 start:10.8405
 view:10.8268
 element:10.6598
 main:10.6494
 term:10.6489
 (:10.3288
 base:10.3122
 screen:10.3121
 current:10.2931
 wid:10.1785

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: (Widget, (Widget -> Bool)), find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:15.6652
 f:12.2021
 test:12.1339
 predicate:12.0899
 check:11.2252
 query:11.2108
 find:11
 type:10.9355
_:10.9015
 is:10.8367
 pred:10.7436
 filter:10.6863
 search:10.4265
s:10.2729
 to:10.1308
 p:10.1303
 target:9.89181
 widget:9.79481
 ->:9.79297
 condition:9.35747
 ,:9.00556

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 predicate:15.5549
 f:15.2432
 test:14.9055
 is:14.2227
 pred:13.7164
 p:13.5268
 filter:13.1079
 match:12.3605
 type:12.3603
 check:12.34
 matches:11.8706
 condition:11.7665
 has:11.5647
 widget:11.5448
 satisfies:10.854
 cond:10.8454
 of:10.7107
 should:10.6816
 find:10.6387
 func:10.6232
 compare:10.2726

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:19.2812
 :14.7205
->:14.2286
_:13.2498
 =>:12.9172
,:12.011

:11.3425
 =:11.1867
::10.9994
1:10.655
(:10.4123
 ==:10.3768
 ~:10.1838
Fn:10.0249
 -:9.90009
 fn:9.76516
 (:9.6209
 -->:9.60481
 f:9.46336
':9.31708
 ?:9.21058

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:

:18.8726
 :16.9712
    :13.8766
 List:13.719
 case:13.6303
 #:12.7718
  :12.725
 if:12.7049
 match:12.5062
        :12.4332
 find:12.2444
     :11.5234
 let:11.5204
                :11.3727
            :11.3409
   :10.9947
 (:10.9815
      :10.9704
 [:10.8312
 fail:10.7917
       :10.7168

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
       :19.9101
   :16.6004
           :14.0915
     :13.6457
      :13.5197
        :13.3377
case:13.3325
    :12.8425

:12.3851
if:12.167
	:11.526
match:11.3911
let:11.3505
 :11.1535
#:11.0813
         :11.0583
               :10.9266
  :10.4358
          :10.1352
                :10.1175
            :9.83403

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
       
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 case:19.4253
 let:17.7156
 if:17.5574
 match:16.3146
 #:15.1064
 List:14.2138
 var:12.1948
 (:11.9231
 predicate:11.7362
 fun:11.513
 (*:11.4758
 rec:11.4691
 find:11.3464
 pred:11.0663
 assert:10.8929
 type:10.5834
 [:10.5588
 go:10.4693
 recursive:10.3761
 func:10.2465
 list:10.1663

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:18.7304
 predicate:15.4872
 #:13.3818
 List:12.6404
 (:12.4066
 pred:12.2605
 :12.0923
 type:11.8319

:11.5772
 find:11.1489
 [:11.0431
 Widget:10.5292
 width:10.4798
 @:10.3685
 filter:10.1923
 !:10.1445
 is:10.1335
 &:10.0675
 list:9.87865
 get:9.66883
 match:9.45621

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.9356
 :18.1448
,:15.0889
 of:14.5908
 in:13.4847
 with:13.4338
  :13.0921
 |:13.0343
    :12.9596
::12.4333
        :12.3113
                :12.2242
            :11.8496
     :11.696
.:11.5435
      :11.5309
 #:11.4021
   :11.2201
 match:11.1812
 {:11.0558
 ::10.541

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
           :22.2417
       :22.1376
         :18.0673
        :17.1589
            :17.1121
               :16.4445
   :16.4338
          :16.3825
     :15.2051

:15.1618
             :15.1377
	:14.9525
                :14.9157
    :14.6988
      :14.4669
#:13.9977
              :13.8141
|:13.054
 :12.4617
  :12.4136
 |:12.077

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.7098
 #:17.426
 (*:12.5848
 //:11.982
 ~:11.8036
 let:11.3043
 match:11.2456
 when:11.1798
 {:11.0917
 ,:11.0193
 ##:11.013
 +:10.9826
 if:10.8259
 ||:10.7987
 /*:10.7899
 (:10.5681
 Column:10.4722
 ::10.4712
 *:10.4576
 Text:10.3547
 Widget:10.1973

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Text:18.9688
 Column:16.6652
 Container:14.1557
 Row:13.2826
 _:12.5516
 (:12.5238
 Widget:12.1683
 column:11.3176
 #:11.1853
 row:11.0028
 widget:10.8327
 container:10.8106
 :10.7821
 []:10.3204
 Col:10.2349
Text:10.1875
 text:9.96113
 ~:9.84556
 w:9.80263
 x:9.78656
 [:9.41314

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:16.3291
(_:15.3564
 _:15.1339
 _,:12.5433
 =>:12.4726
(":11.5082
 ->:10.9726
():10.932
 (:10.8674
,:10.8153
(...):10.3383
((:10.3305
 text:10.0321
($:9.93367
 x:9.69859
 t:9.54111
 w:9.49907
_,:9.4703
({:9.46425
(),:9.28996
 :9.06732

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
_,:19.0213
text:17.8669
string:16.9764
content:16.3534
str:16.1235
x:15.4766
s:15.1095
value:14.9024
txt:14.4898
label:14.0578
t:13.9269
contents:13.918
body:12.8811
a:12.5558
w:12.5011
data:12.4329
c:11.9211
val:11.8658
name:11.8541
message:11.8236
inner:11.8086
Rejected the highest logit candidate _, with logit 19.0213

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: (String, [Attribute]), predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: text
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: text
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.8669
_:14.7108
_,:14.5861
):13.2156
1:12.9038
',:12.8132
 ,:12.3615
,[:12.3073
::11.8375
=:11.5498
o:11.5361
$,:11.5291
Value:11.1967
value:10.9324
ual:10.8921
),:10.7445
str:10.6361
0:10.6338
string:10.6313
 _,:10.3721
 =:10.3163

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:17.9058
 attr:17.1122
 _):16.1562
 att:13.3322
 _:13.1614
 alignment:12.3829
 style:12.2592
 [:11.9586
 properties:11.7621
 styles:11.6462
 align:11.4472
 options:11.4306
 args:11.3207
 attribute:11.1191
 xs:11.0872
 list:11.0865
 text:11.0585
 props:11.001
 params:10.839
_):10.7908
 children:10.3193

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):20.7456
),:17.2545
)=:14.6188
)->:13.6167
_):13.366
_:13.361
 ):13.1236
)::12.9931
1:12.6854
)|:11.9488
__:11.6611
,:11.5606
)):11.3945
...):11.2556
::11.1263
2:11.057
 =:10.9735
=:10.9238
'):10.57
List:10.5073
 as:10.4999

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.7719
 ->:14.0353
 :13.2034
 when:12.9711

:12.6497
 if:12.5325
  :12.0444
      :12.0351
    :12.0183
     :11.9515
                :11.6215
        :11.5565
         :11.54
          :11.3181
             :11.0341
            :10.9799
   :10.8065
       :10.6957
 |:10.6743
              :10.6201
 as:10.5756

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 if:18.6805
 :17.1949

:17.0402
 []:16.0518
 [:15.0523
 List:14.6848
 (:13.8425
 #:13.7965
 predicate:12.5107
  :12.1949
 [(:12.1676
    :11.7624
 ([:11.4917
 Text:11.4812
 let:11.308
                :11.1981
 find:11.1242
        :11.0895
 [],:11.0022
 pred:10.9728
            :10.7992

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string text true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "text" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 predicate:18.666
 (:13.8766
 not:13.4065
 List:12.351
(:11.7318
 !:11.7075
 :11.6427
 pred:11.1889
 @:11.1278
 prediction:10.9428
 Pred:10.8728
pred:10.8366
 String:10.6152
 is:10.5997
 text:10.5603
 Bool:10.4511
_:10.2602
 Text:10.0409
 f:10.0125
 #:9.85156

:9.75355

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  predicate
Nature of error: Expecting type Bool but got inconsistent type (Widget -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string text true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
(:18.8983
 widget:14.221
 (:13.7565
($:13.269
((:12.7078
 #:12.3745
(@:11.9391
.:11.9278
 text:11.8835
 Text:11.8408
([:11.732
 $:11.6865
 then:11.4042
(_:11.1896
(":11.1581
#:11.0177
():10.804
 ==:10.7607
 =:10.7015
[:10.5434
.(:10.5074

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string text true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
Text:19.8881
widget:18.4864
#:14.1522
text:13.9175
Widget:12.6573
Texture:11.847
w:11.7468
 widget:11.2736
wid:10.6229
 Text:10.4904
TextBox:10.4389
 #:10.211
wig:10.0994
String:9.83306
TextView:9.81541
row:9.80041
TextField:9.65488
Column:9.49336
Container:9.46395
Term:9.45189
TEXT:9.44816

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((String, [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.7628
(":17.6934
):15.1613
([:14.3505
()):14.0632
((:12.747
(...:12.4493
 (:12.3823
(_:12.2249
.:12.2208
(*:12.0999
)(:12.0393
(':11.9916
[:11.9685
(?:11.904
("<:11.8695
 text:11.7942
("#:11.5369
($:11.3935
("\:10.8965
 _):10.8361

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "text" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
text:22.312
String:14.7006
string:14.1598
attributes:13.6217
_,:13.4447
Text:12.8792
#:12.851
0:12.5946
 text:12.5212
~:12.3553
[":12.295
test:12.2893
List:12.2202
 "",:11.738
list:11.6204
find:11.5394
null:11.5292
t:11.4875
x:11.1719
**:10.942
#,:10.9317

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [String; (List (Var "Attribute"))]);
           syn = String})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  text
Nature of error: Expecting type (String, [Attribute]) but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "++" | ","
root ::= new-tokens

Top 20 Logits:
,:20.5941
)):13.6169
 ,:12.7344
,[:11.711
 @:11.3739
 ::10.4199
 $:10.397
.:10.3002
::10.2795
",:10.1971
 +:10.1768
 attributes:10.1298
),:10.0076
_:9.95378
',:9.82551
 [],:9.59459
$:9.51841
@:9.51749
 ++:9.35313
[:9.32953
,,:9.08591

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:20.0155
 []:16.712
attributes:15.8063
 attribute:13.3558
 [:12.7376
 List:12.3477
 :12.2192
 attr:12.2096
[]:12.1501
 nil:10.9856
 att:10.7046
 text:10.546
 list:10.3238
 [],:10.0764
 reverse:9.85066
 _:9.7549
 Att:9.68901
 "":9.65208
 @:9.61511
 Nil:9.53218

:9.51275

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)):22.7933
):13.3584
)),:13.3341
))):12.1639
 @:12.0945
 :11.771
::11.7283
 =:11.6421
),:11.6097
))::11.2093
 ::11.1802
 +:11.0233
)){:10.7253
 -:10.6278
))\:10.5265
));:10.4863
:::10.4406
 :::10.4081
')):10.15
 then:10.0835
))$:10.0568
Rejected the highest logit candidate )) with logit 22.7933

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 $:15.2109
 ):14.3305
 then:14.1959
 ::13.9687
 as:12.8945
 @:12.8108
:::11.7893
 =:11.3802
 ||:11.1049
 $$:10.954
 :::10.9113

:10.8351
 :10.7261
 /*:10.4317
 ==:10.3792
 ++:10.3743
 |:10.3013
 ->:9.96225
 in:9.93175
 #:9.88684
@:9.83773
Rejected the highest logit candidate  $ with logit 15.2109

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.4115
then:16.1562
 :13.0672

:11.8742
 ||:9.84777
 &&:9.70044
 [:9.4934
  :9.11036
 {:9.08541
=:8.79212
 ==:8.75027
 #:8.58562
 @:8.39475
 []:8.37753
 ?:8.37684
 else:8.1573
 =:8.11965
 Then:8.11112
||:7.62248
 [[:7.42914
([:7.38975

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 [:18.0269
 :15.0914
 []:14.7585

:14.2849
 #:14.1976
 List:14.1273
 widget:13.7783
 Text:13.5655
 [(:13.1565
[:12.8674
 (:12.8472
 cons:12.2265
 ([:12.125
 [[:11.8457
 #[:11.7109
 list:11.158
 Widget:10.8141
 Cons:10.6232
  :10.5803
 text:10.52
 {:10.4856

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= completions | new-tokens

Top 20 Logits:
Text:16.1589
widget:15.4468
 Text:12.7195
 widget:12.3413
Widget:10.8946
text:10.3798
Texture:9.94253
#:9.8787
 ]:9.70721
pred:9.43163
w:9.00234
Container:8.56344
Test:8.41694

:8.25697
@:8.23323
wid:8.04775
|:7.94111
TextBox:7.91343
 (:7.71936
Column:7.68824
 text:7.53608

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((String, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow ((Prod [String; (List (Var "Attribute"))]), (Var "Widget")
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: ALL errors:
Error in term:
  Text
Nature of error: Expecting type Widget but got inconsistent type ((String, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: Text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((String, [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "]"
root ::= new-tokens

Top 20 Logits:
(:21.6026
(":14.7716
 (:14.3028
]:13.9276
[:13.4105
([:13.1135
((:12.9365
():12.5122
 text:12.0645
.:11.4862
(_:11.475
(*:10.7796
{:10.719
](:10.5011
($:10.3552
(...:10.0955
("#:9.93031
<:9.89621
 ]:9.83539
_:9.79687
_(:9.73967

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "text" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
text:21.4621
 text:14.8304
string:14.6586
attributes:13.4732
String:13.3791
x:11.8975
widget:11.8961
t:11.8464
Text:11.7464
test:11.299
#:10.8599
find:10.7803
str:10.7565
_,:10.7446
content:10.6226
 :10.3587
txt:10.3504
0:10.2403

:10.1941
s:10.145
~:10.043

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <text>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [String; (List (Var "Attribute"))]);
           syn = String})))
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: ALL errors:
Error in term:
  text
Nature of error: Expecting type (String, [Attribute]) but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: text
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: String
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: text
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is String
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "++" | ","
root ::= new-tokens

Top 20 Logits:
,:20.2834
 ,:14.8931
)]:12.4238
 attributes:11.4361
),:11.2231
,[:11.0557
.:10.9272
s:9.90634
,,:9.89478
_:9.72112
):9.7071
::9.43864
 ::9.36965
 :9.29581
_,:9.18702
 [],:9.14264
[:9.11191
 +:8.97473
;:8.88487
 @:8.85066
',:8.84122

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (String, [Attribute])
  LSP: Info: Seft type: (String, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (String, [Attribute])
String <= (String, [Attribute])
String <= (String, [Attribute])
  LSP: Convex: Target types: String, (String, [Attribute])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string text type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:20.2439
attributes:16.7703
 :13.7987
 attribute:13.4278
 [:12.6305
 attr:12.2655
 []:11.9362
 att:11.9168
 at:11.0038
 Att:10.3148

:10.1938
 List:9.94473
  :9.8699
 text:9.85969
 list:9.83704
 arguments:9.76111
 attributed:9.5962
 a:9.17183
 _:9.06286
	:9.03011
 parameters:8.56237

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (String, [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, (String, [Attribute])
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod [String; (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)]:20.5342
):16.551
 ):13.7656
)):12.0922
)](:11.9885
))]:11.9775
)];:11.9166
),:11.7319
]):10.7608
]:10.3257
);:10.1254
 :9.94507
)::9.72868
)}:9.40352
):9.16556
]]:9.10172
)|:9.07356
 ]:8.99459
)":8.93873
)[:8.73654
)`:8.51597
Rejected the highest logit candidate )] with logit 20.5342

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "]"
root ::= new-tokens

Top 20 Logits:
 ]:19.7544
 :::14.5459
 :14.2452
:::13.9366
 else:13.1802
 @:12.9352
 ::12.753
  :12.3706
 as:11.7166
]):11.2569
@:11.2479

:11.2423
    :11.171
                :11.048
 ++:10.9182
   :10.9098
 ):10.8366
     :10.8221
][:10.4982
 ;:10.3105
 }:10.2929

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:19.8933
 :14.4152
else:13.363

:13.0824
 @:12.3347
 end:12.2172
 elif:11.7625
  :11.295
@:10.3507
 otherwise:10.3104
 els:10.1232
                :9.61153
    :9.58529
   :9.3887
     :9.27497
 as:9.0308
 $:8.96732
	:8.93511
      :8.92854
        :8.72741
 el:8.66079

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 []:20.0265
 [:16.1485
 :14.3658
 [];:12.5283
[]:12.2972
 List:12.2773

:11.8317
 nil:11.6325
 #:11.3584
 ([:10.8158
 [[:10.7839
 [(:10.5583
 [],:10.2256
  :10.1498
[:10.031
 empty:9.85821
 (:9.75489
 Text:9.63132
 list:9.5756
 if:9.36066
 ():9.12845

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.8093
 end:17.7474
 :15.6819
  :12.4799
 #:12.4336
                :12.1848
 |:12.1578
 in:12.1201
            :11.724
    :11.3719
        :11.2086
 (*:11.066
   :10.6981
     :10.6555
:::10.6549
 ::10.3988
             :10.2882
#:10.2571
      :10.2313
         :10.1651
end:10.1486

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
           :20.5715
            :15.0364
       :14.9319
               :14.7765
                :14.5521

:13.9763
	:13.4776
          :13.1964
        :13.0849
#:12.7193
   :12.4539
             :12.0209
    :11.9836
         :11.9542
|:11.7503
 :11.5632
              :11.2553
     :11.0134
end:10.813
  :10.5427
      :10.4793

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], text: String, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.2346
 #:16.944
 //:14.093
 end:14.0357
 (*:13.6837
 /*:12.4087
 case:11.6418
 --:11.5135
 else:11.217
 ||:11.1556
 ##:11.0072
 (:10.9037
 if:10.7232
 ,:10.7149
 *:10.6856
 Column:10.6821
 +:10.6677
 ::10.5618
 _:10.5051
 ~:10.448
 @:10.4109

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Column:20.3259
 Row:17.6925
 Container:17.1126
 _:12.6564
 Col:11.8441
 Widget:11.6994
 column:11.2217
 :11.0404
 (:10.7861
 row:10.4085
 R:10.2392
 Color:10.0653
 Text:9.73085
Column:9.71409
 container:9.6724
 widget:9.63843
  :9.59881
 x:9.34589
 Rect:9.09092
 Cont:9.03919
 Cell:9.01307

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Column>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Column
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Column
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Column
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.3754
([:17.5267
 (:14.2858
(_:13.9291
((:13.1885
 children:12.2415
 widget:11.7291
 ([:11.4946
 :11.1348
[:11.0579
 _:10.4101
():10.3385
({:10.2487
  :10.0585
,:9.73712
 child:9.58842
 items:9.55941
(*:9.52819
s:9.4379
(...):9.12513
(...:9.07779

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
widget:17.5034
children:17.3785
contents:14.5462
rows:14.5185
column:14.342
sub:14.2396
columns:14.2317
child:14.1841
elements:14.0099
items:13.8704
content:13.5742
list:13.5416
row:13.1056
xs:13.017
inner:12.7545
ws:12.6359
ele:12.0697
layout:11.897
col:11.7282
w:11.6055
cols:11.4609

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
s:21.5272
_:16.0197
,:13.7237
list:13.3802
List:13.2737
1:11.8551
ss:11.6352
:::11.3839
 list:11.1548
es:10.8616
Array:10.1007
 children:10.0357
Children:9.99864
ls:9.61145
 :::9.49617
0:9.44694
):9.44174
children:9.43008
array:9.07723
set:8.82071
::8.77675

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widgets
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:21.0647
_:15.8854
 ,:15.1796
1:15.1069
',:14.7198
):14.6095
_,:13.7247
0:12.9871
@:12.5544
,[:12.5044
::12.4048
:::11.7666
List:11.6604
2:11.583
 @:11.5651
 :11.5146
),:11.4727
 ::11.3231
':11.0369
 :::11.0176
[:10.9512

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:18.2635
 _):14.842
 attr:14.7943
 column:12.9304
 :12.7493
 _:12.6265
 columns:12.364
 attribute:12.1217
 alignment:12.0926
 att:12.0742
 align:11.7446
attributes:11.484
 row:11.4427
 [:11.4001
 layout:11.3529
 style:11.2114
 at:11.1777
  :11.0746
 styles:10.9755
 children:10.6826
 col:10.5139

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):21.0682
),:16.1797
 ):15.6113
)=:14.0471
1:13.7262
)|:13.6945
_:13.2606
)->:12.2634
,:12.0634
2:11.9859
_):11.867
 :11.7469
)):11.7217
)::11.4498
0:11.3099
'):10.9128
 =:10.721
 ),:10.1992
 =>:10.1689
);:9.80478
 as:9.78168

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.8007
 :14.5047
 |:13.4186

:12.7898
 ||:12.506
  :11.4583
 ->:11.0258
 or:10.6236
    :10.5787
 if:10.4301
 as:10.1236
 when:9.99804
   :9.88601
 :=:9.87965
     :9.83539
      :9.76676
 =:9.33019
 {:9.07857
=>:8.9832
 then:8.91308
        :8.89325

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
 List:16.9554
 :16.0315

:15.465
 if:15.2774
 find:14.7488
 (:13.9855
 widget:13.8015
 let:13.7315
 [:13.2889
 column:11.6439
  :11.5399
 #:11.4597
 Text:11.2041
 list:11.1103
 Column:11.03
 Array:10.9728
 []:10.8417
 filter:10.5808
 Find:10.4966
 fol:10.4813
    :10.3131

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:23.8082
.(:15.8307
_:15.0358
.@:13.3747
@:12.5969
2:12.2879
(:11.7003
.[:11.2165
 @:10.8854
 .:10.8722
.<:10.81
/:10.6707
[:10.5268
x:10.4699
1:10.3629
._:10.2809
:::10.2787
..:10.1614
filter:10.1153
s:10.096
Util:10.0515

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
filter:20.8228
fold:20.4336
concat:18.6461
map:17.8781
rev:17.7528
flat:17.0398
cons:16.5587
append:16.1748
fl:16.0457
init:15.3997
find:15.2718
reverse:14.725
tl:13.7317
join:13.6891
contains:13.4489
merge:13.4327
bind:13.3414
reduce:13.3368
collect:13.0733
add:12.7985
transform:12.5643

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.filter>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              (List (Unknown TypeHole))))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.filter
Nature of error: Expecting type [Widget] but got inconsistent type (((? -> Bool), [?]) -> [?])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.filter
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> [?])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.filter
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:17.4221
((:16.9995
 (:14.0195
(_:12.7458
({:12.502
([:12.417
(\:11.9545
 ((:11.5867
(?:11.4509
i:11.4328
<:11.4006
_:11.2449
(():10.9253
(|:10.8419
 predicate:10.6839

:10.5271
(@:10.1953
(&:10.1874
pred:10.0811
(%:9.8703
p:9.76921

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "predicate" | "type "
root ::= new-tokens

Top 20 Logits:
pred:16.3115
fun:14.368

:11.7132
widget:11.4331
x:11.1834
 (:11.156
lambda:10.821
fn:10.809
 predicate:10.7961
w:10.4704
func:10.1663
Widget:9.67216
find:9.60633
function:9.42679
 fun:9.35105
Text:9.27478
List:9.25019
f:9.04263
Pred:8.98639
if:8.82781
is:8.8226

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(pred

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(pred
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pred>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "pred"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  pred
Nature of error: Variable pred is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: pred
LSP: Generating Completions for prefix: pred
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "icate"
root ::= completions

Top 20 Logits:
icate:23.2124
 =>:11.4158
ic:11.2605
,:10.7292
_:9.84451
 ->:9.79652
->:9.16281
iate:9.16089
):9.08043
inate:9.05537
(:8.94347
licate:8.66037
ica:8.5111
is:8.50825
iction:8.50463
s:8.21795
 predicate:8.2135
.:7.99192
icator:7.79136
 (:7.74309
 :::7.68639

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(pred
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Unknown TypeHole), Bool)); (List (Unknown TypeHole))]);
           syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  predicate
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (Widget -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Var "Widget"), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Var "Widget"), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:17.0973
 ,:13.0761
)(:11.9708
):11.5093
,[:10.3188
 $:9.91538
 _,:9.9144
 o:9.90304
 @:9.84743
 %:9.43444
 :9.27302
 ?:9.09409
 |:8.74811
::8.63842
)[:8.5635
 <:8.53752
 in:8.44516
),:8.4193
<:8.36129
(:8.3584
 _:8.34475

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Widget -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Widget -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:15.6423
 List:14.5419
 [:14.2129
 (:13.9646
 :12.4638
 Column:11.9998
 #:11.3723
 map:11.2375
 find:11.2187

:10.9594
 ([:10.7162
 Text:10.4937
 Widget:10.3996
 Map:9.89821
widget:9.8729
 column:9.85965
 fl:9.65812
 fol:9.65742
 Array:9.45431
 ((:9.36067
 [(:9.28926

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown TypeHole)); syn = (Var "Widget")})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type Widget
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")"
root ::= completions | new-tokens

Top 20 Logits:
s:20.9853
_:14.0866
 @:13.7535
):13.4428
 :::12.5957
:::12.343
@:11.9496
 ::11.3075
 :=:10.7632
::10.681
.:10.3896
 $:10.3623
(:9.98853
 *:9.73124
 ):9.57513
 column:9.41837
 +:9.36866
[:9.31635

:9.01305
 list:8.8648
,:8.78448

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Var "Widget"), Bool));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Var "Widget"), Bool));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):18.1764
 @:16.7218
 ++:13.8085
 +:13.6265
 ):13.5073
:::12.5055
).:12.0631
 :::11.8982
)[:11.8667
 $:11.7421
@:11.6569
)|:11.3277
)$:11.2709
 |:10.9035
);:10.8742
 :10.861
),:10.7465
)):10.5921
)->:10.5489
)^:10.3467
[@:10.3181

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 @:17.125
 ++:16.5173

:15.1
 :13.5146
 +:12.8735
 :::12.5848
 |:11.2108
 $:11.2024
 ||:11.1298
++:11.0611
:::11.0493
@:10.8014
 //:10.7323
 --:10.6854
  :10.5149
 #:10.4473
                :10.3767
 &:9.62757
    :9.56433
 in:9.51854
 %:9.36201

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
 List:16.4557
 (:15.2684
 :13.2084
 find:13.1196

:12.1818
@:12.1817
 [:11.1693
 @:10.9283
 fol:10.8647
 Widget:10.5143
 if:10.3633
 Column:10.1223
 fl:10.0665
 widget:9.80618
 #:9.77619
#:9.74543
 column:9.68234
 (@:9.65711
 ((:9.53153
List:9.18464
 list:9.12506

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:20.8228
_:13.5629
.(:13.2256
(:12.7977
2:12.3663
{:10.8783
find:10.6158
#:10.3631
(":10.3403
[:10.3231
().:10.1908
.@:10.1454
@:10.1453
 (:10.1027
_.:10.0811
.[:10.0675
 .:10.0211
.<:9.93731
:::9.92892

:9.91152
<:9.90593

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
fold:21.6456
concat:19.052
fl:18.5697
flat:18.0474
map:17.7736
init:16.6356
rev:15.8553
reduce:15.5732
filter:15.2951
find:14.6911
join:14.6029
collect:14.15
reverse:13.6377
append:13.5
bind:13.4294
tl:13.3685
cons:13.2776
merge:12.5773
con:12.5192
transform:12.3585
ded:12.2386

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold
Nature of error: Variable List.fold is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold
LSP: Generating Completions for prefix: List.fold
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_left" | "_right"
root ::= completions

Top 20 Logits:
_:24.569
l:18.3377
r:17.7349
(:17.0071
((:15.6857
([:15.238
Left:13.7163
left:13.1208
i:12.2857
(*:12.1701
_(:12.1072
 (:11.8934
Right:11.7873
2:11.4928
f:11.3675
(_:11.3313
right:11.3203
t:11.1098
p:11.0081
({:10.9384
[:10.9356

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold_
Nature of error: Variable List.fold_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold_
LSP: Generating Completions for prefix: List.fold_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "left" | "right"
root ::= completions

Top 20 Logits:
left:26.6253
right:25.7383
map:18.0555
flat:17.4017
fl:15.5175
bottom:15.3619
r:15.1935
l:14.8611
list:14.7396
rig:14.717
down:14.3566
top:14.3452
lef:14.2932
join:14.2726
Left:14.2655
center:14.0481
Right:13.6398
inner:13.5929
with:13.4439
concat:13.3513
all:13.3499

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_left>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                     (Unknown TypeHole)));
                   (Unknown TypeHole); (List (Unknown TypeHole))]),
              (Unknown TypeHole)))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.fold_left
Nature of error: Expecting type [Widget] but got inconsistent type ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.fold_left
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.fold_left
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
((:19.5046
(:17.9639
([:15.364
(@:14.0799
({:13.8255
(?:13.5273
(&:13.408
 (:13.2976
(():13.1964
 ((:12.2328
(__:12.1901
(_:12.1384
(|:12.114
(\:12.0726
(%:11.8227
<:11.2371
(::11.2007

:10.7017
(*:10.6626
():10.5471
(":10.4192
Rejected the highest logit candidate (( with logit 19.5046

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Abs" | "App" | "Column" | "Container" | "List.cons" | "List.contains" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "Row" | "String.starts_with" | "String.transform" | "Text" | "case " | "find_all_widgets_of_type" | "fun " | "if " | "let " | "mod" | "string_compare" | "string_concat" | "type "
root ::= new-tokens

Top 20 Logits:
fun:16.7003
find:16.1913
List:13.6777
 (:13.434

:13.0818
 fun:11.7823
Widget:11.7766
concat:11.4832
lambda:11.4225
fn:11.3293
(\:10.9741
func:10.8511
cons:10.5297
compose:10.4643
 find:10.278
append:10.2078
list:9.83393
 :9.70744
#:9.66092
 #:9.32149
Text:9.31228

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:14.7559
 xs:13.8634
 x:13.3542
 l:12.5569
 widget:12.5115
 (:12.4969
 all:12.4719
 ws:12.3232
 accum:12.1047
 result:11.855
 a:11.8178
 y:11.5469
 list:11.4997
 res:11.0173
 so:10.9643
 results:10.9456
 w:10.748
 sub:10.4157
 state:10.4003
 rs:10.3724
 children:10.1542

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun acc ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:16.29
 ->:13.2078
 widget:12.596
 w:12.2173
 x:11.7629
u:11.4027
 child:11.3095
_:11.2109
 elem:10.9079
 ,:10.3966
 row:10.2689
um:10.1857
 ws:10.0286
 sub:9.87071
 el:9.86793
 element:9.77138
 _,:9.71696
 item:9.61017
1:9.60821
s:9.49965
 (:9.49377

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 w:16.1738
 x:15.6221
 widget:14.7843
 child:14.3253
 sub:13.3778
 elem:13.1979
 el:12.4113
 item:12.4111
 element:12.321
 cur:12.219
 curr:12.215
 next:11.9532
 e:11.7855
 inner:11.747
 row:11.337
 current:11.2777
 wid:11.2359
 ws:10.732
 col:10.4805
 column:10.4792
 it:10.3577

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.5024
d:13.9748
dg:13.8449
gt:13.4801
ig:12.8175
':12.4219
->:12.2633
::11.8619
g:11.7965
i:11.1094
 =:10.9196
 :10.8834
1:10.7535
t:10.7169
,:10.5356
2:10.4257
 ::9.91493
_:9.74227
 =>:9.52604
idge:8.94913
dw:8.94617

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:16.4589
 find:14.9487
 (:13.9496
 List:13.3301
 :13.1493

:12.5392
 let:11.8055
 if:11.5876
 [:11.4703
 w:10.9843
 Text:10.82
acc:10.681
 Widget:10.4175
 #:10.3207
 match:10.2125
 merge:9.96041
 app:9.82261
 fun:9.80874
 cons:9.79246
 Find:9.78701
 Array:9.72509

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:18.9353
 ++:17.6539
@:15.1534
 +:14.4823
 &:13.5386
 #:12.8489
++:12.7366
 :12.7085
 ^:12.4861
 $:12.3036
 <>:11.7642
 |:11.3811
 :::11.3582
 <:11.3158
 ||:11.2928
 %:11.023
 ::10.7956
:::10.498
 &&:10.367
 `@:10.309
 `:10.134

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 find:19.4481
 (:16.6774
@:14.4538
 List:13.9354
 :12.8403
 w:12.0884
 [:12.0464
 @:11.9413
find:11.8655
 Widget:11.3684
 Text:11.13

:10.9774
@@:10.9575
 Find:10.4917
 acc:10.1873
 if:10.1154
(:9.98811
*:9.88153
#:9.83822
 ((:9.8114
[:9.5937

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find
Nature of error: Variable find is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:21.4238
All:12.607
(:12.5709
all:11.5233
er:10.9164
Widget:10.587
 all:9.86
,:9.78031
((:8.8251
Sub:8.64767
W:8.61819
(),:8.56582
 (:8.47777
-:8.42358
.:8.40279
_(:8.29035
__:8.11904
_,:7.96108
Children:7.90865
([:7.89073
attr:7.84705

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_
Nature of error: Variable find_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:25.8773
any:14.8024
al:12.9854
always:12.835
only:12.768
 all:12.3262
attributes:12.3132
widget:12.1957
and:12.0611
in:12.0463
at:11.7959
able:11.6532
some:11.5566
a:11.5493
add:11.4492
single:11.436
allow:11.3119
active:11.1008
with:11.0928
if:10.896
ally:10.8732

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all
Nature of error: Variable find_all is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:23.0333
(:13.9153
Widget:11.3662
,:10.9812
widget:10.2273
[:10.1609
([:9.73666
...:9.65482
__:9.5996
 (:9.45712

:9.41856
 widget:9.29198
(),:9.15152
-:9.11997
((:9.07796
():9.06699
_(:8.78909
(@:8.74395
l:8.6376
::8.47183
\_:8.26453

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:23.5496
attributes:14.9336
of:14.4604
text:14.1106
wig:13.8681
w:13.8304
cont:13.8289
sub:13.7873
wid:13.552
attr:13.4868
layout:13.4079
align:13.3724
elements:13.3022
the:13.2219
container:13.1438
attribute:13.1317
children:13.0421
Widget:13.0386
type:12.9215
columns:12.7673
with:12.6251

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:21.6295
_:12.8702
(:12.33
ss:9.97775
[:9.7422
,:9.54123
$:9.0528
es:8.92689
 (:8.45508
as:8.25228

:8.12045
():8.06909
.:8.05606
ts:7.9477
 columns:7.78415
::7.75975
 :7.74854
 =:7.71974
rows:7.71168
':7.70095
`:7.52197

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:24.1273
(:15.8228
,:12.1001
([:11.385
[:11.0001
 (:10.7478
Of:10.7241
 of:10.6915
(),:10.3328
((:10.1071

:10.0784
-:9.68964
():9.62192
__:9.59858
_(:9.52589
2:9.47485
)(:9.28524
1:9.25004
 :8.93025
.:8.8263
::8.71092

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:27.0378
o:14.6173
list:14.5284
 of:13.5929
in:13.4748
off:13.3888
on:12.684
Of:12.5514
over:12.3615
or:12.2473
for:11.9255
if:11.8686
only:11.7319
by:11.589
at:11.4405
with:11.3913
0:11.351
opt:10.9992
to:10.9829
out:10.8382
old:10.7685

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:23.811
(:11.7902
_(:10.0708
 _:9.6957
-:9.25757
_,:9.15075

:9.08703
 (:8.79811
 :8.64279
__:8.64021
_):8.39516
 padding:8.32715
\_:8.26057
():8.07838
__(:7.67061
[:7.55399
(_:7.5247
([:7.44119
(":7.40085
_{:7.29057
_.:7.28073

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:27.599
string:16.4171
term:15.8384
text:15.6208
Type:14.7247
tree:13.8779
types:13.833
ype:13.7483
this:13.6236
style:13.4467
value:13.0992
TYPE:12.9752
attribute:12.7118
 type:12.277
te:12.2135
time:12.1618
atype:12.1071
ter:12.0815
ty:12.0205
typeof:11.9332
t:11.9036

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [?] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | "::"
root ::= new-tokens

Top 20 Logits:
(:21.6829
 (:16.8584
((:15.1164
 w:13.9174
([:13.4025
(@:12.664
(),:12.5199
[:12.4444
.(:11.7023
(?:11.5791
($:11.5236
({:11.5128
():11.4634
#:11.3993
_:11.271
<:11.2615

:11.2047
(!:11.199
(*:11.1468
,:11.1265
_(:10.9893

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "acc" | "case " | "if " | "let " | "type " | "w" | "widget"
root ::= completions | new-tokens

Top 20 Logits:
w:21.3971
Widget:14.8183
Text:13.8019
Column:13.5145
 w:13.4602
Container:13.3815
widget:12.5882
pred:11.7011
Row:11.3583
find:10.9967
W:10.8274
#:10.8235

:10.4743
acc:10.1794
 Text:9.90892
 Widget:9.68704
List:9.65313
x:9.58804
 :9.54675
Texture:9.37746
container:9.2646

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "idget"
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:19.9195
 ,:15.3333
),:14.4153
):11.8132
)),:11.6288
 predicate:11.1102
)(:10.5321
)):10.4768
 :10.463
::10.3375
,\:10.241
,[:10.1416
 pred:9.94056
 ::9.92823
,(:9.91018
 ),:9.72107
.:9.56115
 @:9.25455
,,:9.00451
)[:8.78052
 (:8.68851

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc predicate ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  fun  if  let  predicate type  w
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "acc" | "case " | "fun " | "if " | "let " | "predicate" | "type " | "w"
root ::= new-tokens

Top 20 Logits:
 predicate:20.6614
pred:14.4102
 :13.8296
 pred:12.4751
 fun:11.5216
 f:11.2547
 (:10.4658
 attribute:10.4309
 Text:10.4045
 text:10.3803
 Pred:10.3619
 prediction:10.126

:10.0752
 find:9.88044
 widget:9.73342
 predict:9.6151
 attributes:9.57605
 p:9.29043
 [:9.07209
  :9.00527
 if:9.00297

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc predicate ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  fun  if  let  predicate type  w
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
),:20.2048
):16.3428
 ),:14.9422
)):14.774
)),:14.345
)[:11.578
 :11.423
 ):11.3069
)(:10.7884
)::10.7452
).:10.2063
);:10.1205
()),:10.0156
),(:9.99572
 =:9.6837
))::9.363
));:9.31681
::9.28442
)",:9.18089
),\:8.72628
,:8.64817
Rejected the highest logit candidate ), with logit 20.2048

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 end:16.458
 ,:16.2129
 :13.4124
 ):12.0663

:11.302
 ),:11.2628
 [],:10.7892
end:10.7863
 in:10.7535
  :10.3534
(),:10.1218
   :9.84058
 if:9.65646
 @:9.27839
 ;:9.07813
 as:8.95949
 _,:8.72746
 ?:8.65466
    :8.65355
 +:8.6269
                :8.52325
Rejected the highest logit candidate  end with logit 16.458

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [],:18.0623
[:15.2762
 [:14.6576
 widget:13.2224
[]):12.4583
 List:12.4511
 (:12.3264
 []:12.2116
 find:12.045
 :11.893
 Widget:10.0032
widget:9.81517
[]:9.80579
 Text:9.80491
find:9.78368

:9.60291
 _,:9.58627
 [[:9.41822
 acc:9.18062
 ([:9.17112
 list:8.92087
Rejected the highest logit candidate  [], with logit 18.0623

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
],:18.9729
 ],:16.2673
 :14.8669
Column:12.764
),:12.1255
 ]:12.1018
],[:11.5224
[]:10.9305
 ),:10.5418
](:10.4881
List:10.0316
Text:9.94353
w:9.91105
  :9.57152
]):9.53381
>,:9.22544
Row:9.02913
Widget:8.92689
?:8.78384
].:8.73436
column:8.68896
Rejected the highest logit candidate ], with logit 18.9729

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ],:20.2253
]):19.9207
],[:18.0475
](:17.15
],:16.1898
 ]:15.3004
].:15.2423
][:15.0247
 ),:13.6688
]{:13.573

:12.6482
].[:12.6237
](#:11.7796
 },:11.0586
)):11.0543
 ):10.8861
	:10.7364
0:10.5898
](#):10.3317
 ];:10.1708
](/:10.0683
Rejected the highest logit candidate  ], with logit 20.2253

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
               :14.7485
            :14.1136
                :14.0973
           :13.6444
],:13.1132
       :11.563
        :11.4438
    :11.2491
             :11.1537
   :11.0898

:11.0343
              :10.9909
]):10.3812
]:9.92186
	:9.48769
 ],:9.43215
\:9.35367
          :9.28314
 :9.14204
     :8.9387
|:8.90986

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
               

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
               
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ],:17.9138
 ]:14.0502
 if:13.9659
 Column:13.8692
 |:13.5745
 Text:13.2438
 ),:12.3092
 for:12.2883
 #:12.0318
 Container:11.6416
 Row:11.3346
 match:11.2323
 },:10.9551
 ||:10.9511
 fun:10.9046
]):10.8669
 end:10.8548
 (:10.7459
 let:10.6479
 find:10.4059
 @:10.358
Rejected the highest logit candidate  ], with logit 17.9138

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if ? then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 predicate:16.9663
 not:13.7554
 List:13.467
 (:13.0487
 find:11.8178
 !:11.6315
 pred:11.3722
 w:11.2076
 widget:11.1505
 is:10.9618
 :10.7955
 Text:10.4793
 true:10.2752
 any:9.99156
 Widget:9.93071

:9.91269
 prediction:9.89561
 contains:9.87645
 match:9.87578
 let:9.63177
 length:9.57314

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  predicate
Nature of error: Expecting type Bool but got inconsistent type (Widget -> Bool)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
(:20.1791
 (:16.0169
 then:13.9964
((:13.6818
 Column:12.2718
():12.2623
(@:11.9547
([:11.6258
 is:11.4471
 =:11.1904

:11.056
 widget:11.0049
Column:10.8655
 Widget:10.7607
 ==:10.7278
 Text:10.5021
($:10.4676
({:10.3206
::10.2411
(.:10.2189
 #:10.0066

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(?) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(?) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(?) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
Column:19.0806
 Column:13.9646
widget:13.3786
Container:13.1972
Text:13.0172
Widget:12.9863
w:12.0703
Row:11.9884
Col:11.6802
column:11.3196

:11.2482
 widget:10.3486
Columns:10.3228
 Container:10.092
text:10.0777
 Text:9.7412
 :9.23478
 w:9.16743
row:9.1374
 Widget:8.88494
List:8.73207

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Column>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  Column
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: Column
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Column
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.16
([:17.6413
 (:14.2525
((:13.417
()):12.2341
):11.9301
[:11.6258
(":11.6258
(_:11.4457
(*:11.422
():11.319
 widget:11.0298
 ):10.9203
 [:10.5473
({:10.2905

:10.1438
 ([:10.0136
(...:9.71123
(?:9.65313
)(:9.62125
(-:9.61494

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
widget:19.1241
List:14.0994
find:12.9707
w:12.5039
 widget:12.4727
Widget:12.243

:12.0324
text:11.5001
[]:11.3959
 [:10.9193
acc:10.9063
column:10.7972
Text:10.766
list:10.6557
attributes:10.162
_,:10.1168
columns:9.82596
 :9.74608
if:9.71511
width:9.64501
row:9.63728

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn = (Var "Widget")})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widget)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  widget
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type Widget
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")" | "::"
root ::= completions | new-tokens

Top 20 Logits:
s:21.5112
,:14.7674
_:10.9854
 ,:10.4054

:10.291
 s:10.1657
@:9.98574
:::9.82441
ss:9.73388
::9.60389
_,:9.53844
 =:9.40862
[:9.38972
es:9.36005
 @:9.33569
)):9.15891
 ::9.06286
.:8.96669
1:8.86091
):8.80273
(:8.55021

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn =
           (List
              (Rec ("\206\177",
                 (Sum
                    [("Text",
                      (Some (Prod [String; (List (Var "Attribute"))])));
                      ("Column",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Row",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Container",
                       (Some (Prod
                                [(Var "\206\177"); (List (Var "Attribute"))])))
                      ])
                 )))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  widgets
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:19.7768
 ,:13.5281
)):12.6729
 @:12.4506
),:12.3615
@:12.1703
):11.3974

:11.0869
,[:10.9598
::10.9245
 +:10.8007
 ::10.1885
,,:9.97839
 :9.87517
 [],:9.57201
 :::9.55001
[@:9.53271
 =:9.52304
 [:9.34238
)]:9.16255
[:9.0493

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, ?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, ?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, ?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:19.6551
attributes:16.0435
 [:13.2938
 attribute:12.1012
 :11.9669
 []:11.1691
 attr:10.8673
 att:10.5906

:10.5341
 List:10.4902
 at:9.84083
  :9.74209
 text:9.68168
 list:9.62251
 Att:9.59915
 ):9.50824
 arguments:9.35741
[]:9.32535
 [],:9.27624
 (:9.13451
 columns:9.07597

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)):20.2572
):18.3094
)),:15.8077
 ):14.1081
))]:13.8401
 :13.5575
))::13.2458
));:12.7811
))):12.5977
),:12.568
)))):12.3646
)).:11.7438
)){:11.4284
)]:11.1765
)));:11.1659
))`:10.0312
)[:9.91966
)::9.82915
]):9.73072
):9.63562
))\:9.5857
Rejected the highest logit candidate )) with logit 20.2572

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):19.3076
 ),:13.381

:11.8429
 :11.731
 ]:11.6801
 then:10.8958
 as:10.3198
  :10.2061
 );:9.47369
 ){:9.46955
   :9.41568
]):9.38631
 else:9.0841
 ,:9.07341
    :8.94209
                :8.91296
 ::8.68434
 ||:8.47855
 :::8.42722
 ],:8.30484
 =:8.2676

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.2757
 &&:14.6664
 :14.5339

:14.4987
 ||:13.5082
then:13.282
  :11.547
 ]:11.0187
]:10.8048
 else:10.4214
 end:10.3196
                :10.246
 =:9.90676
 ):9.83507
 ?:9.83023
    :9.82919
   :9.82358
 =>:9.5503
 {:9.38965
 ->:9.28809
 ==:9.11971

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:18.7739
 Column:16.4867

:14.0295
 :13.7411
 (:13.6665
 List:12.7484
 Text:12.5019
 []:11.8084
 Col:11.4636
 Widget:11.3809
 find:11.2901
 ([:11.2153
 [(:11.1737
 Container:11.0537
  :10.8296
 widget:10.2131
[:10.1195
 column:9.9995
 list:9.88426
 #:9.78989
    :9.7645

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[?]])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[?]])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[?]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Column:17.5201
 Column:16.3182

:13.112
Text:12.0848
Widget:11.4997
Col:11.2463
Container:11.0232
 :10.981
 ]:10.4477
Columns:10.3203
widget:10.0675
 Text:9.99119
 (:9.86887
find:9.86629
  :9.67858
column:9.66415
List:9.41179
Row:9.2066
Color:9.06004
w:9.04903
text:8.93195

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Column>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[(([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)]])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: Column
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Column
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "]"
root ::= new-tokens

Top 20 Logits:
(:20.435
([:15.1101
 (:14.3099
((:11.8108
]:11.7427
 widget:11.0166
[:10.7845
():10.7575
(*:10.5568
 ]:10.5353

:10.177
(":9.80849
::9.46255
,:9.45969
(...:9.24266
(_:9.13439
(?:9.11433
](:9.10307
 :9.03954
Widget:8.94498
 [:8.52823

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= completions | new-tokens

Top 20 Logits:
widget:20.7939
List:13.6426

:13.1114
find:12.8866
Widget:12.7327
 widget:12.713
w:12.0323
text:11.4186
column:11.3576
Text:11.3005
[]:11.162
attributes:11.134
acc:10.8259
 :10.813
list:10.7849
width:10.5343
columns:10.3349
wig:10.1656
  :9.79136
wid:9.74985
,:9.6968

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn = (Var "Widget")})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widget) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type Widget
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")" | "::"
root ::= completions | new-tokens

Top 20 Logits:
s:21.1714
,:13.34
_:9.10272
 [],:8.85371
 s:8.66319
ss:8.65766
[:8.61875
List:8.55973
(:8.28967
.:7.95831
es:7.93647
):7.92595
xs:7.92088
]:7.88488
 widget:7.87651
 xs:7.8711
 list:7.83572
 (:7.78271
 columns:7.75816
 []:7.65833
 :7.65315

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn =
           (List
              (Rec ("\206\177",
                 (Sum
                    [("Text",
                      (Some (Prod [String; (List (Var "Attribute"))])));
                      ("Column",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Row",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Container",
                       (Some (Prod
                                [(Var "\206\177"); (List (Var "Attribute"))])))
                      ])
                 )))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widgets
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.1703
 ,:12.9024

:10.7325
)]:10.6689
),:10.6537
,[:10.6203
):10.5305
@:10.4145
 @:10.1755
,,:9.91831
::9.65476
 attributes:9.50456
 :9.47418
[:9.38551
.:8.9434
 [],:8.93353
 +:8.69079
[@:8.5884
 ::8.47876
 attr:8.44966
 [:8.42401

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, ?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, ?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, ?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:20.4221
attributes:15.8415
 attribute:12.6228
 :12.5008
 [:11.6162

:11.3489
 att:11.1548
 attr:11.1265
 []:10.628
 at:10.5306
  :10.1627
 Att:10.0029
 attributed:9.68621
 arguments:9.57334
	:9.43176
   :9.25754
 list:9.20805
 a:8.9625
 ):8.81404
    :8.81376
 text:8.775

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
)]:18.2088
):17.8392
),:12.8908
 ):12.5941
)];:12.5781
]:12.3628
)):12.1803
)](:12.1519
))]:11.9139
)::11.7213
 :10.7254

:10.6284
)[:10.5297
]):10.3258
);:9.89487
)|:9.63843
).:9.44212
));:9.29172
):9.21231
]]:9.13436
)}:9.04587
Rejected the highest logit candidate )] with logit 18.2088

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "]"
root ::= new-tokens

Top 20 Logits:
 ]:19.8128
 :::13.5886

:13.0993
 :12.6922
:::11.8609
 ::11.7011
 ];:11.3996
 ]]:11.1466
 ],:10.97
 as:10.8866
 ):10.406
  :10.2909
]):10.1916
][:10.0205
].:9.66677
],:9.38601
 else:9.27317
 [:9.19286
 }:9.18706
]:9.14245
 @:9.01288

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:20.4279

:13.6052
 :12.8776
 @:12.7467
 end:12.3023
 elif:12.1677
 +:11.9198
]:11.7369
else:11.1983
 ]:11.1124
 []:10.9739
 els:10.8627
 ++:10.8355
@:10.6801
  :10.4444
   :10.376
 :::10.2889
]):10.2457
 otherwise:9.99676
 ::9.77549
)]:9.69845

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 []:20.3709
 [],:17.2237
 [:15.3274
 List:12.6163
 :12.3596

:12.2533
[]:12.2505
 (:11.7514
 find:11.6336
 [];:11.5928
 nil:11.162
 [[:10.7139
 acc:10.6613
 Text:10.6459
 ():10.5629
 list:10.0264
 ([:9.9998
 ]:9.9225
 ],:9.8537
 w:9.73023
  :9.48413

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:

:17.8825
 end:17.3216
],:16.5273
]):16.2358
),:15.6711
 :15.3862
 ],:15.2592
]:15.1962
 |:14.3439
  :14.2134
   :13.6474
 ),:13.0948
    :13.0328
                :12.9724
 ]:12.9517
)):12.8215
]),:12.6687
end:12.4861
):12.3858
 ,:12.29
 ):12.2479

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:
           :18.4849
            :18.2815
                :16.721
               :15.8853
       :13.8522
        :13.7902
             :13.7689
   :13.4714
],:13.0563
    :12.8902
              :12.784

:12.6358
          :11.9782
]):11.786
end:10.9834
]:10.9753
in:10.967
         :10.734
	:10.7283
 :10.0233
     :9.87228

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:
 ],:18.2032
 |:16.7755
 end:16.3496
 ),:15.9548
 ]:15.0852
 in:14.2694
 ,:14.1665
 ):14.0347
 },:11.8851
 }):11.5487
 widget:11.4521
 List:11.2678
 w:10.9906
]):10.8018
 @:10.799
 let:10.6034
 #:10.472
 Widget:10.4103
 (:10.3358
 ||:10.3006
 ).:10.2455
Rejected the highest logit candidate  ], with logit 18.2032

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[Widget]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[Widget]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (List (Var "Widget")))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:

:14.4765
 in:13.3606
 ,:13.0986
)):12.6707
 ):12.6168
 end:12.3082
),:12.0398
@:11.8697
 @:11.5382
 :11.5273
::11.228
in:10.9968
 ::10.9308
 |:10.9097
);:10.6193
end:10.5675
:::10.2004
 +:10.0799
  :10.0638
   :10.0066
 ++:9.84581

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[Widget]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[Widget]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (List (Var "Widget")))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
           :16.8027
       :16.161
            :14.8019
   :13.9667
end:13.5404

:12.9512
in:12.9429
               :12.6908
                :12.5565
        :12.1182
          :11.5491
    :11.2808
	:10.9754
):10.7779
|:10.4707
,:10.4492
}:10.4273
         :10.3479
             :10.2598
              :9.79489
     :9.68186

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[Widget]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[Widget]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (List (Var "Widget")))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 |:18.8841
 ,:15.442
 end:15.4411
 ):14.7015
 Column:12.2157
 widget:11.8584
 (:11.8451
 @:11.5657
 in:11.4001
 <:11.3555
 #:11.1202
 ),:11.1127
 case:11.0845
 if:10.9632
 +:10.7726
 ~:10.7516
 Row:10.7035
 ():10.6654
 }:10.5184
 //:10.2333
 :::10.233
Rejected the highest logit candidate  | with logit 18.8841

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:16.9385
 :13.2888
([:12.8255
 |:12.649
 (:12.4926
 widget:12.4235
(:12.4204
  :12.1055
            :11.7313
    :11.6701
   :11.5475
 end:11.543
                :11.1697
 ([:11.0984
        :11.047
@:10.9756
]:10.6547
 @:10.6152
 =:10.5441
|:10.4598
 ::10.4256

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
           :18.6105
       :15.7088
            :15.0049
   :14.1873
end:13.7562

:13.7327
in:13.523
                :12.8116
        :12.6625
          :12.4638
               :12.3852
    :11.8417
(*:10.7565
|:10.6984
#:10.6811
     :10.6567
         :10.6288
	:10.5326
else:10.2638
      :10.1315
             :10.0776

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.9314
 Column:14.7075
 #:13.5461
 (:13.4424
 widget:13.047
 end:12.9904
 case:12.7918
 Row:12.7746
 //:12.6464
 Text:11.9065
 (*:11.8795
 ():11.8636
 ,:11.4728
 Container:11.329
 _:11.3073
 ::11.3047
 if:11.136
 =:11.02
 ...:10.9259
 /*:10.8643
 ||:10.8515

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Row:20.5622
 Container:14.9711
 _:12.7433
 Column:11.6201
Row:11.0011
 Text:10.7027
 row:10.5557
 :10.4254
 (:9.93555
 Widget:9.67552
 otherwise:9.41918
  :9.31024

:9.11486
 F:8.77796
 :8.75863
 R:8.73459
 Grid:8.68415
 ...:8.68355
 w:8.62039
 other:8.50652
 x:8.4963

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  Row
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Row
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Row
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.7569
([:14.6789
 (:14.6557
(_:13.7027
((:12.0732
 =>:11.6723
 widget:11.4357
():10.6959
 _:10.3685

:9.94041
   :9.89154
  :9.65406
 :9.6338
 ->:9.43316
(...):9.24543
[:9.205
 =:9.00523
 ([:8.98965
,:8.98858
::8.71514
_(:8.59717

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
widget:18.928
row:13.2748
children:12.783
rows:12.7627
 widget:12.6884
columns:12.5776
_,:12.2604
column:11.9178
Widget:11.0894
ws:10.9937
w:10.975
wid:10.9705
list:10.7793
text:10.7449
child:10.6024
items:10.5956
layout:10.5728
elements:10.4069
wig:10.3688
first:10.3062
width:10.2344

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
s:20.7834
,:14.8621
ss:12.8667
_:11.3772
es:11.224
):10.2692
1:9.90439
ds:9.61452
z:9.54213
ts:9.45619
x:9.44329
sl:9.31773
list:9.27837
_,:9.16243
rs:8.83514
 list:8.81916
 rows:8.77284
row:8.74355
gs:8.73954
st:8.69589
sa:8.68175

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widgets
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:20.5837
 ,:13.067
):12.7459
_,:11.6122
',:11.505
1:11.4651
,[:11.333
::11.2429
_:11.0416
,,:10.8646
 attributes:10.5724
),:10.5102
2:10.1553
 _,:9.87149
0:9.75263
 :9.40755
 [:9.25241
 ::9.15068
@:9.147
 [],:9.04716
 row:9.02174

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:19.3293
attributes:13.6549
 attr:13.5501
 attribute:13.2048
 _):12.9448
 att:12.5515
 at:12.3106
 _:11.5919
 align:11.3625
 :11.3134
 row:11.3132
 alignment:11.174
 [:11.0464
 a:10.3548
 padding:10.0519
 Att:9.8715
 style:9.86928
 styles:9.78469
 text:9.77283
 arguments:9.76217
 columns:9.74908

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):20.1188
)=:14.0628
 ):13.541
),:12.666
)):12.0083
 =>:11.5577
)->:11.4646
)|:11.2837

:10.821
_):10.4252
1:10.3358
,:10.2753
2:10.1182
 :9.60165
);:9.46482
_:9.46333
)::9.31766
 =:9.31281
)>:9.19402
]:9.07767
)]:9.06455

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:21.6652
 :13.6331
  :12.5264
   :12.2226

:11.7321
 =:11.1867
    :11.1222
 ->:11.1113
 :=:10.191
     :10.0533
 as:10.0481
 |:9.94669
=>:9.86853
      :9.85003
 return:9.39064
 if:9.31504
 ||:9.16676
       :9.12792
                :9.08017
 :::8.97202
 when:8.86399

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
 List:19.5855
 :14.008

:13.7419
 find:12.6434
 (:12.5324
List:12.0457
 []:11.8617
  :11.7762
 if:11.6791
 [:11.662
 widget:11.4141
 let:10.9992
 #:10.9065
 list:10.5048
   :10.3145
    :9.65712
 Text:9.56086
 Widget:9.42725
 ?:9.35061
 fail:9.2505
[]:9.23612

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:21.7869
List:10.7916
(:10.4011
.(:9.43836
 .:9.30001
_:9.14876
::8.86211

:8.29403
rev:8.2628
Re:8.20588
..:8.20496
.[:8.12157
list:7.8759
:::7.76172
,:7.66273
._:7.58397
1:7.58383
():7.58136
((:7.5768
s:7.56776
2:7.56642

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
filter:24.3574
fold:21.6373
concat:17.7743
map:17.0622
fl:14.9657
folder:14.8039
find:14.7189
con:14.6919
reduce:14.2836
reverse:14.0148
flat:13.9303
cons:13.6222
append:13.5406
rev:13.4413
join:13.1621
fill:13.059
fil:12.8211
comb:12.7011
union:12.6276
Filter:12.5841
merge:12.5195

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.filter>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              (List (Unknown TypeHole))))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List.filter
Nature of error: Expecting type [Widget] but got inconsistent type (((? -> Bool), [?]) -> [?])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.filter
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> [?])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.filter
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:20.4427
((:13.831
 (:13.2388
():12.1906
p:11.7413
_:11.2647
pred:11.0979
(\:11.0935
([:10.7731
(@:10.6499

:10.5533
 predicate:10.2235
_(:9.95872
(_:9.85978
{:9.84922
.(:9.84069
[:9.80232
i:9.43704
({:9.3206
(?:9.28903
2:9.25559

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "predicate" | "type "
root ::= new-tokens

Top 20 Logits:
pred:21.84
fun:13.077
 predicate:12.3594
find:12.2768

:11.8026
widget:10.9826
f:10.6499
Pred:10.5583
List:10.4593
Text:10.3186
attribute:10.2258
attributes:10.1777
text:10.007
 pred:9.92338
if:9.84222
 (:9.83061
func:9.80177
x:9.74365
lambda:9.70658
pre:9.69564
Widget:9.64093

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(pred

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(pred
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pred>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "pred"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  pred
Nature of error: Variable pred is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: pred
LSP: Generating Completions for prefix: pred
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "icate"
root ::= completions

Top 20 Logits:
icate:27.2417
ificate:14.882
ic:13.3283
ate:12.8991
licate:12.8323
inate:11.9931
ice:11.8087
iate:11.7359
uate:11.2449
ata:10.9832
uce:10.9312
imate:10.6505
iction:10.3129
ict:10.0124
ica:9.82766
c:9.33071
itute:9.07431
icator:9.07075
icane:9.05113
ategy:8.97224
itate:8.79615

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(pred
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Unknown TypeHole), Bool)); (List (Unknown TypeHole))]);
           syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  predicate
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (Widget -> Bool)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Var "Widget"), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Var "Widget"), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:19.8945
(:12.6662
 ,:12.6456
,(:12.0612
,[:11.2506
):10.3487
)(:10.1829
 Text:10.0144
 (:10.0107
(),:9.94427
 :9.74749
,,:9.73984

:9.71768
((:9.56795
.:9.06076
::9.05883
([:8.96019
[:8.8357
),:8.8093
 row:8.44298
Text:8.28174

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Widget -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Widget -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:21.9331
widget:13.087
 row:12.8045
 [:12.7288
 :12.3062
 List:12.2259
 Row:12.1014
 (:11.9959
 find:11.5277
 Widget:11.4326
 w:10.817
 rows:10.6074
 @:10.3197
 wid:10.0962
 list:9.9277
 ):9.79589
  :9.73829

:9.69336
 text:9.47898
 Column:9.46526
 attributes:9.44294

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown TypeHole)); syn = (Var "Widget")})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type Widget
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")"
root ::= completions | new-tokens

Top 20 Logits:
s:20.4445
):11.7677
,:8.76222

:8.07804
_:8.01566
),:7.92455
);:7.76098
':7.56666
).:7.5111
)):7.44701
S:7.36777
ss:7.32061
 ):7.30781
[:7.2783
sd:6.89362
 :6.81024
)::6.80291
'):6.75154
.:6.74183
 =:6.71584
d:6.67386

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Var "Widget"), Bool));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Var "Widget"), Bool));
     (List
        (Rec ("\206\177",
           (Sum
              [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                ("Column",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Row",
                 (Some (Prod
                          [(List (Var "\206\177")); (List (Var "Attribute"))])));
                ("Container",
                 (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                ])
           )))
     ])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):20.0865
 @:13.8615
 ):13.7247

:12.1638
),:11.1771
)):10.9509
,:10.7716
[@:10.6135
)[:10.3179
 +:10.2735
@:10.0902
).:10.0801
 :10.0512
)]:9.9986
[:9.95734
:::9.83013
 :::9.69303
);:9.40114
_:9.38316
]:9.33096
.:9.32288

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 @:20.8163
 :13.6434
@:13.3731

:12.8769
 +:12.6447
 &:11.2782
  :10.7978
 ++:10.6528
 List:10.3107
 $:10.2231
 end:10.222
 *:10.1374
 |:10.1116
 :::10.0086
   :9.81195
 #:9.78946
 //:9.63063
 (@:9.01639
    :8.87847
 <:8.83667
 ::8.61207

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
 List:18.9066
 :13.6298
 find:13.477
 (:13.464

:12.3379
List:11.8888
  :11.5599
 @:11.267
 [:11.1606
 list:10.1197
@:9.88891
   :9.8766
    :9.58183
 fol:9.20421
 #:8.81067
 (@:8.77281
 if:8.69883
     :8.68399
 .:8.61432
 widget:8.60849
 :8.46245

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:20.0683
 .:9.70037
(:9.33652
.(:9.30899
.@:8.55478
..:8.52342

:8.4532
_:7.55888
,:7.5487
::7.41147
{:7.22357
.<:7.10939
().:6.92681
.[:6.89569
...:6.80263
 (:6.79238
2:6.52803
(":6.46118
\:6.4421
@:6.34463
.\:6.31776

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
fold:24.9303
fl:15.866
map:14.8972
fol:14.3845
filter:14.2962
concat:14.2724
rev:13.6024
flat:13.4609
reduce:13.1355
 fol:12.8894
find:12.2324
folder:11.93
reverse:11.7367

:11.6426
con:11.3145
f:11.3071
fill:10.5727
init:10.5607
fd:10.4506
F:10.1915
append:10.1824

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List.fold
Nature of error: Variable List.fold is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold
LSP: Generating Completions for prefix: List.fold
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_left" | "_right"
root ::= completions

Top 20 Logits:
_:25.0012
l:13.0895
(:12.8514
left:12.5713
Left:12.5429
-:12.0689
r:10.9882
_(:10.9629
([:10.871
((:10.8335
 left:10.7711
__:10.4009

:10.2508
Right:9.71028
.:9.6005
i:9.38893
():9.22559
right:9.10316
L:9.04745
(_:9.024
ed:8.96771

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List.fold_
Nature of error: Variable List.fold_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold_
LSP: Generating Completions for prefix: List.fold_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "left" | "right"
root ::= completions

Top 20 Logits:
left:27.7613
right:21.6715
Left:15.5242
lef:14.9402
l:14.6491
let:13.7112
r:13.2865
leaf:13.0555
light:12.9066
 left:12.6989
lt:12.6383
list:12.5861
lower:12.4979
LEFT:12.3573
map:12.1438
le:12.1374
like:11.8945
last:11.8879
line:11.766
layer:11.761
level:11.7521

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_left>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                     (Unknown TypeHole)));
                   (Unknown TypeHole); (List (Unknown TypeHole))]),
              (Unknown TypeHole)))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List.fold_left
Nature of error: Expecting type [Widget] but got inconsistent type ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.fold_left
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.fold_left
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:20.8815
((:16.1891
 (:14.7816
([:12.9923
(@:12.4747
(?:12.265
(\:12.2519
():12.23

:11.8485
({:10.9483
($:10.5427
(::10.5063
(():10.292
(|:10.2293
[:10.1049
{:10.041
(_:9.98425
_:9.93836
?(:9.75798
 ((:9.71199
(&:9.67606

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Abs" | "App" | "Column" | "Container" | "List.cons" | "List.contains" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "Row" | "String.starts_with" | "String.transform" | "Text" | "case " | "find_all_widgets_of_type" | "fun " | "if " | "let " | "mod" | "string_compare" | "string_concat" | "type "
root ::= new-tokens

Top 20 Logits:
fun:21.6526
find:15.8547
 fun:15.1242

:15.0758
 (:12.6437
func:12.6176
pred:12.5523
List:12.3863
lambda:11.6613
 :11.454
f:11.2001
fn:10.7416
  :10.7229
function:10.6681
acc:10.614
Fun:10.471
   :10.2563
 find:10.2301
(\:10.0733
list:9.60545
if:9.47285

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:21.8829
 (:12.6821
 xs:12.5869
 a:12.0428
 x:11.917
 ac:11.8628
 :11.5161
 accum:10.9068
 l:10.8929
,:10.7234
 w:10.5803
 list:10.4012
 all:10.2343
 [:10.1653
 ws:10.0105
 _,:9.99555
 y:9.95851

:9.90168
 res:9.58711
 result:9.38089
 _:9.37366

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun acc ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:20.6094
 ->:13.1904
 w:13.0083
 ,:12.6519
1:11.3131
 _,:11.1772
_,:10.917
2:10.8954
_:10.7747
',:10.7003
::10.2994
 widget:10.1088
w:9.88675
 (:9.65333
 :9.58336

:9.56042
 ::9.40466
 ws:9.36826
 x:9.29515
.:9.07644
0:8.99367

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, ?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "Text" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 w:22.0052
w:14.0223
 x:13.4975
 widget:12.9327
 r:12.1983
 row:12.0225
 :11.9278
 y:11.2732
 e:11.147
 h:10.9958
 a:10.9565
 column:10.8255
 c:10.7582
 wid:10.4384
 child:10.3583
 (:10.313
 v:10.2666
 i:10.2333
 f:10.0783
 z:10.0225
 col:10.0125

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs Alignment App Center Color Column Container End Margin Padding Reverse Row Start Text Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:22.169
->:13.9385
 :12.7484
 -:11.7699
 =>:11.6797
2:11.2474
 =:11.1929
1:10.9059
,:10.9058

:10.6702
':10.5108
::10.1481
  :9.9861
 :::9.90928
 >:9.81049
 ::9.75758
 <-:9.71291
 →:9.66465
 -->:9.36895
 widget:9.28369
 w:9.11878

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w ->

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w ->
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:19.5881
 :14.8201
 find:13.6606
 (:13.0666

:12.8877
 [:12.2667
 if:11.6868
 w:11.5706
acc:11.5248
 List:11.4328
 ac:11.4179
  :11.0048
 let:10.8622
 Text:9.80211
 ,:9.74582
 {:9.69954
   :9.63645
 Acc:9.48571
 #:9.40772
 [],:9.10307
 case:9.0189

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <acc>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: acc
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: acc
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:19.7743
@:14.5785
 :14.1396
 +:12.4447

:11.1147
 *:10.7945
 &:10.629
 ++:10.2888
 ::10.2173
 <:9.98461
 #:9.90848
 =:9.53442
 >:9.4558
 |:9.4207
 \:9.25878
 :::9.14574
  :9.13691
,:9.09638
 .:8.78153
 -:8.76791
(@:8.7129

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acc" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "w" | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 find:21.076
 :13.2785
 (:12.3749
find:12.1917
 [:11.7625

:10.7488
 List:10.7431
 @:10.4375
 Text:10.2347
 w:10.1312
 Widget:10.1066
 f:9.67408
 Find:9.60513
 if:9.43704
@:9.40229
  :9.09736
 fin:9.0098
[:8.94322
 acc:8.79626
 ,:8.67234
 list:8.5177

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find
Nature of error: Variable find is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:22.5811
All:9.6271
(:9.5296
 all:9.38624

:9.29383
-:9.28196
all:8.99033
\_:8.16549
.:8.07508
[:7.49734
_(:7.39114
 :7.37819
Text:7.29174
	:7.09857
 _:6.8297
 (:6.56738
1:6.47321
__:6.42884
,:6.22716
(":6.01127
 align:5.79176

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_
Nature of error: Variable find_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:26.7376
find:13.9356
 all:13.2513
al:12.9168
a:12.6037
any:12.1844
All:11.8797
add:11.7735
as:11.2962
text:11.0341
alls:11.0114
attribute:10.8917
array:10.8716
attributes:10.8692
for:10.8596
list:10.8527
attr:10.7161
widget:10.6756
always:10.6682
and:10.5004
ALL:10.4697

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all
Nature of error: Variable find_all is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:21.5691
-:9.5564
(:9.43509
\_:8.31668
.:7.6998

:7.44692
(":7.07952
,:6.88938
 :6.85922
p:6.7672
_":6.4432
max:6.36573
2:6.36565
[:6.34635
():6.33323
_(:6.26912
width:6.23127
 (:6.15996
w:6.15653
{:6.14528
term:6.14275

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:25.1313
Widget:14.0369
w:13.3589
transform:13.026
webpack:12.839
wig:12.6359
text:12.5468
 widget:12.0655
words:11.4563
string:11.136
width:11.0767
all:11.0736
web:11.0236
with:10.9872
world:10.9775
watch:10.9339
sub:10.8968
wid:10.839
list:10.6699
strings:10.5679
layout:10.4705

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widget
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:22.3021
(:13.2703
_:10.9073
es:9.85548
t:9.69554
,:9.67788

:8.95716
():8.85403
[:8.72293
 (:8.50398
 of:8.37688
 :7.8925
.:7.87848
{:7.86225
c:7.31146
as:7.26725
):7.22096
a:7.12339
S:6.98245
с:6.87974
ss:6.8709

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:22.0425
(:12.3243
Of:11.6215
 of:10.7307
,:10.1377
of:9.59601
[:9.42374
(),:9.00971
-:8.81237

:8.81047
.:8.73455
0:8.51576
_,:8.49332
 (:8.49071
():8.26746
 :7.9729
((:7.92743
__:7.78034
_(:7.75407
([:7.6743
 ,:7.67206

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:27.3693
 of:15.3954
Of:14.5182
or:12.5368
o:12.4902
ot:12.4092
0:11.8675
oc:11.2764
to:11.2302
off:10.9721
opt:10.9039

:10.8882
<:10.7959
pos:10.6784
co:10.2835
only:10.2348
com:10.1715
no:10.1637
od:10.1448
out:10.1165
op:9.96482

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:23.9158
(:11.1524
\_:10.9807
-:10.4773
_,:10.3711
_(:9.79716
[:9.78847
 _:9.66002
_*:9.27705

:9.2205
 :8.99475
__:8.98476
_.:8.98152
([:8.59103
_{:8.47476
,:8.30054
 (:8.17919
():8.03965
{:8.01647
P:7.91604
.:7.84569

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:26.3533
text:19.1421
types:15.059
typ:14.9777
te:14.7721
ty:13.7241
 type:13.596
test:13.5839
true:12.6848
tex:12.3974
typen:11.6223
Type:11.5765
temp:11.5432
time:11.4699
typename:11.1824
three:11.047
texte:11.0324

:11.0146
t:10.9854
table:10.9539
tree:10.8739

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [?] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Unknown Internal))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | "::"
root ::= new-tokens

Top 20 Logits:
(:21.0008
 (:14.3506
([:12.5878
[:11.8511
((:11.7679
(),:11.3515
,:11.1546

:11.0034
():10.7406
 ,:10.4211
 :10.417
w:10.304
 w:10.1739
(*:9.76278
(@:9.30155
)(:9.14889
(?:9.01178
($:8.89814
_:8.71522
{:8.62435
(":8.61083

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc attributes widgets [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acc acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  w widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "acc" | "case " | "if " | "let " | "type " | "w" | "widget"
root ::= completions | new-tokens

Top 20 Logits:
w:22.1883
Row:13.7925
Text:12.7765
 w:12.6799
Widget:12.5133
widget:12.1442
Column:12.0557

:11.7089
Container:11.1438
 :10.3436
row:10.1761
column:9.56347
x:9.52451
,:9.41186
 Column:9.24865
acc:9.22573
text:9.1855
r:9.03296
W:9.03126
R:9.02675
 ,:8.85668

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <w>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: w
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: w
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "idget"
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:20.4045
 ,:14.0532
),:12.4239
):10.8268
 :10.6419
,[:10.2339

:10.2135
 predicate:9.50661
,,:9.46739
)):8.90753
::8.89525
[:8.74751
 [],:8.72443
 widget:8.61597
(),:8.52369
)[:8.45404
 ),:8.40718
 ):8.30067
 (:8.21792
)),:8.19596
.:8.18035

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, ?)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc predicate ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  fun  if  let  predicate type  w
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text acc case  if  let  type  w widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "acc" | "case " | "fun " | "if " | "let " | "predicate" | "type " | "w"
root ::= new-tokens

Top 20 Logits:
 predicate:21.755
pred:13.1774
 :13.1302
 pred:12.4944
 [:11.3563

:10.7022
 p:10.6628
 attributes:10.4732
 attribute:10.427
 f:10.2048
 prediction:10.1938
 Pred:9.74314
 fun:9.37447
  :9.27891
 widget:9.27742
 prede:9.18172
 text:9.12284
 predict:9.10616
 find:8.76246
 (:8.64935
 ):8.61552

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: w acc predicate ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right acc case  fun  if  let  predicate type  w
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
),:19.6651
):19.5823
)):14.3071
)[:13.4468
)),:13.2777
 ),:12.8063
),(:11.8521
 ):11.7897
 :11.6714
)(:11.3761
)::11.1066
)]:10.7873
);:10.7701
))):10.533

:10.4288
).:10.4047
));:10.2521
)",:10.0881
))]:10.0012
[:9.93415
))::9.92326
Rejected the highest logit candidate ), with logit 19.6651

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {w: ?, acc: ?, attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate)
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> [Widget])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
   (List (Var "Widget"))))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:20.2029
 :13.85

:12.3968
 [:11.3027
 end:11.1387
 [],:11.0613
 ):10.5157
 ),:10.0575
 @:9.58612
 +:9.49209
 ],:9.35462
  :9.32446
 [[:9.22961
 ::8.9612
 ]:8.83428
 ;:8.70078
 _,:8.65389
 ([:8.4395
 :::8.2557
 (:8.20527
   :8.11305

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> [Widget]), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (List (Var "Widget"))));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), ?)  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Column Container List.cons List.contains List.filter List.fold_left List.fold_right List.init Row String.starts_with String.transform Text case  find_all_widgets_of_type fun  if  let  mod string_compare string_concat type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[:22.3275
 [:18.2445
[]:16.2861
[]):15.0042

:13.9592
 :13.5445
 []:13.2532
[[:12.2974
 [],:12.1189
 if:11.7879
 [[:11.243
[(:11.1049
[,:11.06
  :11.0401
[{:10.9454
([:10.5286
if:10.4405
[@:10.4196
(:10.416
 List:10.3708
 (:10.3355

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (Unknown Internal))])
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 :21.1648

:16.629
  :15.8538
 if:13.4851
   :13.2554
    :12.85
 ]:12.7098
                :12.4588
]):12.2083
     :11.9211
 Row:11.5888
      :11.2495
        :11.2188
 ],:11.1909
            :11.1861
Row:11.1292
],:11.0763
if:10.9894
       :10.9312
 [:10.8308
 ):10.6871

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:22.6638
]):16.5789
 if:16.0668
 ]:13.6925
	:12.3321
 ],:12.0518
0:11.538
 //:10.8197
][:10.7145
 (:10.654
 #:10.6321
            :10.4256
1:10.3503
],[:10.3223
 ):10.2812
                :10.2534
)):10.2051
    :10.1143
].:10.1143
](:10.0005
 Row:9.96713

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
               :23.6467
                :17.8909
              :16.1828
           :15.8669
             :15.4066
            :14.8348
       :13.6837

:13.216
if:12.8433
	:12.4721
   :12.319
        :11.4843
         :11.4261
          :11.3531
    :10.7031
#:10.595
     :10.4176
 :9.99655
      :9.56143
  :9.1724
If:8.69909

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
               

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
               
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:23.6925
 #:14.609
 Row:14.0214
 (:13.8315
 Text:13.2395
 [:12.8132
 []:11.8556
 Column:11.8556
 If:11.5984
 //:11.4054
 (*:11.3093
 List:11.2939
 find:11.0213
 case:10.872
 {:10.3917
 ,:10.3258
 print:10.3144
 *:10.2993

:10.2892
 let:10.2738
 ():10.2356

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if ? then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 predicate:20.7586
 (:12.9032
 :12.1401
 prediction:11.5996
 pred:11.216
 not:10.0545
(:9.92757
 p:9.84217
 true:9.81609

:9.74761
 !:9.67492
 List:9.66335
 Pred:9.61508
 find:9.56761
pred:9.39751
 predict:9.34018
 Row:9.18327
 is:9.17657
  :8.92217
 prede:8.8595
 list:8.65526

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool; syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  predicate
Nature of error: Expecting type Bool but got inconsistent type (Widget -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
(:20.8535
 (:13.2484
((:11.8337
 predicate:11.289
(_:9.29033
 pred:9.18537
::9.03819
():8.78208

:8.45777
 :8.41426
=:8.33883
[:8.32561
 Widget:8.30586
([:8.1109
Widget:7.97567
pred:7.82172
 ==:7.73025
{:7.63336
 is:7.61258
(":7.55964
 widget:7.36521

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(?) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(?) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(?) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
Row:20.9887
Column:16.2393
Text:14.1666
Container:12.8109
 Row:12.6159
row:11.8872
Widget:11.4796
Rows:10.327
Col:10.1501

:10.0737
R:9.87864
 Column:9.82817
Columns:9.413
text:9.09563
Raw:9.0927
Ro:9.07548
column:9.0506
ROW:8.93647
Rect:8.89092
Color:8.69909
List:8.56928

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(List
                     (Rec ("\206\177",
                        (Sum
                           [("Text",
                             (Some (Prod [String; (List (Var "Attribute"))])));
                             ("Column",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Row",
                              (Some (Prod
                                       [(List (Var "\206\177"));
                                         (List (Var "Attribute"))])));
                             ("Container",
                              (Some (Prod
                                       [(Var "\206\177");
                                         (List (Var "Attribute"))])))
                             ])
                        )));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  Row
Nature of error: Expecting type Widget but got inconsistent type (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: Row
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Row
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.7125
 (:13.1637
([:12.9986
((:11.1635
[:10.8179
   :9.92531
():9.8886
  :9.8469
widget:9.84623
Widget:9.73616
 widget:9.71526
,:9.36819
 :9.33116
)(:9.32933
):9.3057
()):9.18844
(":8.88601
(*:8.85332
r:8.84266
{:8.68766
(_:8.55027

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Widget
  LSP: Convex: Target types: Widget
  LSP: Convex: Backpack: 
  LSP: Convex: Base: widget ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= new-tokens

Top 20 Logits:
widget:21.5182
Widget:13.2157
attributes:12.8464
row:12.8051
 widget:12.4392
w:11.367
List:11.1621
text:10.9438
Row:10.807
wig:10.745

:10.6501
rows:10.5553
width:10.342
list:10.2748
columns:10.226
column:10.147
Column:10.0849
 :9.83618
layout:9.64533
wid:9.6058
  :9.56483

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn = (Var "Widget")})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widget)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type Widget
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")" | "::"
root ::= completions | new-tokens

Top 20 Logits:
s:23.7043
,:13.9442
[:10.7429
):10.5765
es:10.322
ss:10.2093
t:10.1589
=:10.0664
S:9.79486
d:9.59968
(:9.52921
_:9.47713
8:9.37541
Widget:9.06728
1:9.03593
a:8.97862
i:8.87771
as:8.87388
z:8.78817
e:8.72948
ts:8.70901

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn =
           (List
              (Rec ("\206\177",
                 (Sum
                    [("Text",
                      (Some (Prod [String; (List (Var "Attribute"))])));
                      ("Column",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Row",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Container",
                       (Some (Prod
                                [(Var "\206\177"); (List (Var "Attribute"))])))
                      ])
                 )))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  widgets
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.0267
 ,:11.6756
,[:11.1186
)):9.51403
),:9.34519
):9.31842
.:9.15563
[:9.13606
s:8.98314
,,:8.76828
::8.75882
 :8.62841
1:8.54963
 widget:8.32934
 [:8.32906
(:8.20268
,(:8.17444
 row:8.11905
 (:8.06738
 -:7.77597
 [],:7.59201

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, ?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, ?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, ?)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:21.339
attributes:14.6402
 attribute:12.4524
 :11.8433
 [:11.4488
 att:11.4469
 attr:11.0124
 at:10.8956
 Att:10.7226
 row:10.7021
 arguments:9.93194
 attributed:9.62826
 text:9.5074
 a:9.50372
  :9.34057
 _):9.12039
 list:9.09345
 ):8.98238
 align:8.98054

:8.87828
 Row:8.85281

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
):19.6553
)):16.647
 ):14.442
 :12.4814
),:12.3676
))]:12.0372
)),:11.8904
))::11.3345
)]:11.1278
]:10.9717
))):10.6219
));:10.263
)))):10.0454

:10.0431
)[:9.78456
  :9.65743
)));:9.34018
)::9.27682
)).:9.27234
]):9.20636
)){:9.19501

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Widget
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):23.0759
 :13.2577
 ),:12.7758
 ]:11.2966

:11.2907
  :10.9311
 );:10.2499
 ).:10.2099
 ,:9.57665
   :9.45852
 ){:9.44467
 =:9.21691
 ::9.11539
    :9.04994
 [:8.97986
 ==:8.97906
 ;:8.92291
 }:8.68814
 as:8.46345
 !:8.37318
 ?:8.19991

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:23.3517
then:14.0866
 :13.762

:11.6494
  :11.1105
 ?:10.9183
 than:10.78
 &&:10.508
 ||:10.495
   :10.335
                :10.2081
 Then:9.9931
 else:9.91823
    :9.57173
     :9.25635
 or:9.22004
      :9.16699
              :9.05
 ):8.75518
 THEN:8.72634
 [:8.70209

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:23.0719
 []:13.8533
 Row:13.4923
 :12.9552
[:12.6205
 Column:11.768
 (:11.2943
 [(:11.2667

:11.2512
 Text:10.9811
 [[:10.6917
 List:10.6062
  :10.3996
 ([:10.2221
 row:10.0376
 Container:9.7201
   :9.68199
 [],:9.47524
    :9.46831
 find:9.46664
 Widget:9.41802

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[?]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[?]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then ? else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[?]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
Row:19.4421
Column:14.8945
 Row:13.9149
Text:12.3492
Container:11.6056

:11.1543
Widget:10.5831
row:10.1438
R:9.42358
Col:9.10094
Ro:9.05153
 :8.89929
Rect:8.8145
Rows:8.7504
Rule:8.73513
ROW:8.56089
text:8.47188
Raw:8.30244
  :8.12243
 Column:8.05606
List:8.03123

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Row>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[(([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: Row
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget)
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Row
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "]"
root ::= new-tokens

Top 20 Logits:
(:21.0561
 (:13.1002
([:12.6565
():11.221
((:10.9135
 ]:10.5926
]:10.4823
[:10.4759
Widget:9.31987
(*:9.29489
,:9.1596
 widget:9.14456

:9.0277
 :8.89961
(),:8.76343
  :8.57435
   :8.50884
::8.3673
[]:8.34599
(?:8.3337
](:8.29702

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget" | "widgets"
root ::= completions | new-tokens

Top 20 Logits:
widget:21.8312
Widget:13.2044
attributes:12.5083
 widget:12.3868
row:12.0028
w:11.7482
text:11.4675
wig:11.1058

:10.9686
Row:10.742
List:10.7279
Column:10.6395
width:10.4564
wid:10.2272
columns:10.1436
Text:10.1202
column:10.0444
 :9.97495
list:9.79607
rows:9.72109
layout:9.23524

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn = (Var "Widget")})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widget) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type Widget
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Var "Widget")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | ")" | "::"
root ::= completions | new-tokens

Top 20 Logits:
s:22.5557
,:13.5811
ss:10.7887
es:9.89724
ws:9.78811
(:9.27588
_:8.80334
 s:8.76748
):8.56014
1:8.34488
Widget:8.00407
=:7.97134

:7.95939
js:7.92898
.:7.91876
z:7.88239
]:7.8574
 :7.85101
[:7.81717
 =:7.70515
S:7.69325

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(List
                  (Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     )));
                (List (Var "Attribute"))]);
           syn =
           (List
              (Rec ("\206\177",
                 (Sum
                    [("Text",
                      (Some (Prod [String; (List (Var "Attribute"))])));
                      ("Column",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Row",
                       (Some (Prod
                                [(List (Var "\206\177"));
                                  (List (Var "Attribute"))])));
                      ("Container",
                       (Some (Prod
                                [(Var "\206\177"); (List (Var "Attribute"))])))
                      ])
                 )))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  widgets
Nature of error: Expecting type ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) but got inconsistent type [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widgets
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (List
   (Rec ("\206\177",
      (Sum
         [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
           ("Column",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Row",
            (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
           ("Container",
            (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
           ])
      )))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.2792
 ,:11.6724
,[:10.3066
)]:9.94129
):8.97586
,]:8.8344
',:8.80946
.:8.72305
::8.6002
),:8.56578
,,:8.44483
 :8.01841

:7.88468
_:7.867
-:7.82024
]:7.73146
[:7.7301
 [],:7.54351
s:7.5286
;:7.50539
,(:7.45342

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, ?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Seft type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, ?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, ?) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
[rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}] <= ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Convex: Target types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widgets
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Margin" | "Padding" | "[" | "[]" | "attributes" | "case " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 attributes:21.5197
attributes:14.5797
 attribute:12.6316
 :11.983
 att:11.3082
 Att:10.8771
 [:10.6374
 attr:10.548
 at:10.4389
 arguments:9.93037

:9.80445
 attributed:9.61881
  :9.23317
 a:9.21426
 text:9.14851
 ):9.08299
 row:9.04435
 []:8.65869
 Row:8.63649
	:8.49701
Attributes:8.47033

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: [Attribute]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Attribute]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: attributes
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}], ([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (List
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      ))) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(List
       (Rec ("\206\177",
          (Sum
             [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
               ("Column",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Row",
                (Some (Prod
                         [(List (Var "\206\177")); (List (Var "Attribute"))])));
               ("Container",
                (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
               ])
          )));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String)) <= [Attribute]
  LSP: Convex: Target types: [Attribute], (Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Alignment Color List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Margin Padding [ [] attributes case  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "@"
root ::= new-tokens

Top 20 Logits:
):19.7956
)]:16.4525
]:12.7976
 ):12.3824
),:11.9462
)](:10.8657
)::10.7041

:10.5518
)];:10.4612
)):10.2457
 :9.77818
))]:9.61458
)[:8.84026
);:8.74872
)|:8.72651
):8.69315
)*:8.66916
]):8.54473
::8.3463
)`:8.31884
).:8.31348

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Widget
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "]"
root ::= new-tokens

Top 20 Logits:
 ]:23.3568
 :13.6753

:12.7162
 ):12.6117
 ],:11.9765
  :11.2996
 ::11.2633
 }:11.0199
 ]]:10.7881
 ,:10.492
 ];:10.3273
 ;:10.1085
 else:10.0387
   :9.51954
 [:9.45991
]:9.44023
 :::9.40276
 -:9.1588
 as:9.09494
	:9.09292
    :8.96331

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:23.3138
 :14.3426

:12.9799
 elif:12.4443
else:12.1969
 end:12.0831
  :11.9572
   :11.9434
 els:11.7352
 @:11.1966
	:10.4431
    :10.132
 otherwise:9.96824
 el:9.89225
 ]:9.30135
 e:9.03576
]:8.99336
     :8.93938
                :8.92273
       :8.91345
      :8.88082

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | "widgets" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 []:23.9661
 [],:15.8172
 [:15.4414
[]:14.0951
 :13.2365
 [];:12.7426

:12.5263
 (:11.8141
 nil:10.8177
 List:10.7508
 if:10.439
 ():10.3354
 [[:10.2143
  :10.1385
 ([:10.0809
 {}:9.8268
 list:9.7619
 false:9.65126
 [(:9.59074
   :9.45232
 "":9.22418

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes widgets predicate widget find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widgets ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:

:18.7584
 :13.0837
                :12.3835
]):12.2184
  :12.152
 end:11.8683
    :11.8587
            :11.6351
   :11.5764
]:11.4203
        :11.0092
 ]:10.547
      :10.0134
              :9.98232
           :9.95751
],:9.79208
     :9.76823
       :9.70272
          :9.69027
             :9.10599
         :9.05787

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:
           :23.1869
            :18.2287
                :15.9786
               :15.5882
       :14.7121
          :14.6907
             :14.413

:14.3531
        :14.0337
              :13.3832
    :12.7054
]:12.4592
	:12.446
   :12.2943
         :12.2367
]):12.0815
]]:10.7759
      :10.572
     :10.5458
 :10.2061
  :10.1697

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:
 ]:21.5034
 ],:17.5165
 ]]:14.2523
 ):14.218
 end:13.7799
 ];:12.7853
]):12.2522
 ,:12.1054
 }:11.8352
 |:11.7124
 //:11.2549
 in:10.7603
 </:10.5264
 (:10.4788
 ),:10.3511
 #:10.3414
 ...:10.1937

:10.1902
 ():10.1818
 ;:10.0581
 }):9.84886

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[Widget]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[Widget]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (List (Var "Widget")))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:

:18.387
            :12.8256
 :12.7019
 ):12.3016
  :12.1981
   :12.1339
    :12.0937
                :11.6823
)):11.3006
        :11.1579
 end:10.4894
     :10.3751
       :10.2303
end:10.1161
          :10.0908
      :10.0735
           :9.97022
),:9.81963
              :9.7402
         :9.72225
             :9.71067

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[Widget]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[Widget]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (List (Var "Widget")))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
           :19.8722
       :15.6258
            :15.0898
   :13.4076
                :13.3892

:13.0773
               :12.7937
          :12.774
        :12.5539
):12.0763
in:11.9338
    :11.8504
end:11.7777
	:11.4915
         :11.3736
             :11.0982
     :10.8613
              :10.6633
let:10.289
      :10.1021
  :9.92593

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [[Widget]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[Widget]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (List (Var "Widget"))));
     (List (List (Var "Widget")))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ):22.1188
 ),:15.5915
 |:15.141
 ,:13.952
 );:13.6736
 end:13.5578
 //:12.4282
 ).:12.3427
)):12.1701

:11.8537
 #:11.8037
 :::11.3775
 (:11.3675
 }:11.2487
 ...:10.9258
 ]:10.7684
 }):10.668
 ():10.6311
 /*:10.608
 ::10.3971
 (*:10.2524

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.1992
 :13.7803
            :13.764
  :13.0351
    :12.884
   :12.5807
        :12.5168
                :12.0429
 |:11.6078
     :11.3905
      :11.293
       :10.9568
@:10.8318
          :10.7712
           :10.441
 in:10.438
 end:10.3852
 @:10.3108
         :10.2748
             :10.045
              :9.83052

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
           :20.1174
       :17.0193
   :15.5082
            :14.9632
in:14.2151
end:13.9976
          :13.883

:13.3512
        :13.1574
                :12.6513
               :12.1731
    :12.1633
         :11.6501
	:11.5636
#:11.3797
|:11.3333
      :11.1026
     :11.005
(*:10.9252
             :10.4085
  :10.3985

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
           

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
           
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widgets: [rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "::" | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:23.471
 #:16.2147
 end:14.2672
 Container:13.1223
 Column:13.0801
 //:12.9558
 (*:12.9053
 Row:12.3312
 if:12.1386
 /*:12.1059
 (:11.6462
 Text:11.314
 case:11.0231
 else:11.0193
 }:10.8322
 ~:10.8237
 ##:10.7796
 _:10.7566
 in:10.6213
 *:10.5331
 ||:10.4687

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            |

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            |
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Container:21.0577
 _:12.8441
Container:12.4474
 Column:12.0102
 Widget:11.2267
 :11.1784
 container:10.9762
 Cont:10.8645
 Text:10.5039
 (:10.4349
 Con:10.1022
 :10.0323
 C:10.0066
  :9.79322
 Box:9.5103
 widget:9.4065
 F:9.12066
 #:8.8923
 Stack:8.88685
 App:8.87578

:8.75046

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Container>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "Widget");
           syn =
           (Arrow (
              (Prod
                 [(Rec ("\206\177",
                     (Sum
                        [("Text",
                          (Some (Prod [String; (List (Var "Attribute"))])));
                          ("Column",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Row",
                           (Some (Prod
                                    [(List (Var "\206\177"));
                                      (List (Var "Attribute"))])));
                          ("Container",
                           (Some (Prod
                                    [(Var "\206\177");
                                      (List (Var "Attribute"))])))
                          ])
                     ));
                   (List (Var "Attribute"))]),
              (Var "Widget")))})))
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  Container
Nature of error: Expecting type Widget but got inconsistent type ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Container
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Container
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.5124
 (:15.4116
((:15.0169
([:13.8505
(_:13.3775
 =>:11.7609
 widget:11.607
({:11.604
():11.2281
{:10.7144
 _:10.5885
 {:10.4648
Widget:10.0194
(?:9.73412
(*:9.47974
[:9.40413
 ((:9.37118
(':9.25179
(":9.1893
 child:9.04149

:9.01815

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "Row" | "Text" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
widget:16.7134
child:15.5312
w:15.0914
inner:15.0395
content:14.1086
container:13.083
contents:12.8845
sub:12.875
box:12.5751
cont:12.3601
body:12.1226
text:11.8867
x:11.8203
Widget:11.6876
nested:11.5208
 widget:11.278
c:11.1403
wid:11.0604
a:10.8931
children:10.5086
column:10.506

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]), predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: widget
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
,:20.1175
s:16.1573
',:14.7365
_:14.3197
1:13.7322
_,:13.61
 ,:13.4567
::12.8595
):12.8166
':11.5621
0:11.5207
2:11.4649
 ::10.8058
),:10.6281
@:10.5674
x:10.0288
,,:9.76916
,[:9.6489
t:9.5617
'):9.53491
y:9.48828

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Seft type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
            ("Column",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Row",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Container",
             (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
            ])
       ));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( Column Container Row Text _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Alignment" | "Color" | "Margin" | "Padding" | "[" | "[]" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 attributes:18.8374
 attr:13.6335
 _):13.499
attributes:13.2618
 attribute:13.2299
 [:12.4665
 _:11.8261
 widget:11.7902
 att:11.6331
 container:11.4097
 at:11.2199
 :11.1893
 (:10.7478
 alignment:10.5699
 align:10.563
 text:10.257
 padding:10.2105
 a:9.97363
 list:9.80809
 Att:9.77774
 inner:9.54378

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <attributes>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Attribute]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute])
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: attributes
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
            ("Column",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Row",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Container",
             (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
            ])
       ));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: attributes
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (List
   (Sum
      [("Padding", (Some Int)); ("Margin", (Some Int));
        ("Alignment",
         (Some (Sum [("Start", None); ("Center", None); ("End", None)])));
        ("Color", (Some String))]))
LSP: commas: self syn is (Prod
   [(Rec ("\206\177",
       (Sum
          [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
            ("Column",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Row",
             (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
            ("Container",
             (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
            ])
       ));
     (List (Var "Attribute"))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( Alignment Color Margin Padding [ [] _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
):20.5526
)=:15.0174
 ):14.3572
)):12.6476
 =>:12.3951
,:11.9378
)->:11.8342
),:11.502

:11.3184
_):10.6538
)|:10.2608
1:10.2539
_:10.1911
)::10.1291
 :10.0561
 =:9.80514
2:9.75889
)]:9.6408
 as:9.54051
)>:9.40773
]:9.2733

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Widget
  LSP: Info: Seft type: Widget
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: Widget
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:21.4812
 :13.4598
 ->:12.1633
  :11.2981

:11.2358
 =:11.0782
 as:10.633
   :10.1251
 if:10.1244
=>:10.0738
 {:9.5613
    :9.45196
 ==>:9.27401
 :::9.16747
 :=:9.11682
 when:8.96504
 |:8.78162
     :8.7402
 >:8.68441
 ::8.68121
      :8.57028

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) =>

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) =>
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 List:17.5488
 find:15.9254
 [:15.4967
 if:15.1191
 (:15.0226
 :14.3366

:13.6337
  :12.1455
 let:11.5579
 []:11.4557
[:11.2775
 ([:11.2672
 widget:10.7843
find:10.6667
 #:10.612
List:10.5539
 list:10.4705
 Widget:10.2779
 case:10.1833
 @:10.1784
   :10.1523

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:22.6116
.(:12.0856
{:11.2926
(:11.2803
:::10.4578
find:10.371
.[:10.3083
 .:10.3008
@:10.1894
<:10.1001
.@:9.95328
.<:9.92261
 {:9.90432
_:9.75411

:9.47483
([:9.1527
Utils:9.03024
[:8.87593
 find:8.79062
(@:8.77425
 @:8.71686

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "filter" | "fold_left" | "fold_right" | "init" | "rev" | "tl"
root ::= completions

Top 20 Logits:
filter:20.1774
fold:17.8932
append:16.0437
cons:15.8682
concat:15.7731
map:14.1888
find:14.0662
rev:13.798
con:13.2974
reverse:13.2714
fl:12.6569
union:12.633
sing:12.5364
extend:12.4979
add:11.7587
insert:11.5937
folder:11.5418
flat:11.3057
push:11.2151
Cons:11.2107
fill:11.1488

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.filter>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: (((? -> Bool), [?]) -> [?])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              (List (Unknown TypeHole))))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  List.filter
Nature of error: Expecting type [Widget] but got inconsistent type (((? -> Bool), [?]) -> [?])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: List.filter
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> [?])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: List.filter
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:21.057
([:14.2757
 (:13.8892
((:13.4743
(@:12.4469
():11.8039
_:11.7256
p:11.3621
[:11.3362
pred:11.2897
({:10.9719
(\:10.9499

:10.904
{:10.6669
(&:10.1126
(_:10.0285
@:9.75497
ed:9.70143
(():9.60121
<:9.52477
.(:9.31974

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "predicate" | "type "
root ::= new-tokens

Top 20 Logits:
pred:22.1865
fun:12.9705

:12.4761
 predicate:12.134
find:11.7627
attributes:11.4473
if:10.7806
Pred:10.7121
widget:10.6431
List:10.64
attribute:10.6292
f:10.3848
 pred:10.3704
Widget:10.3517
lambda:10.006
x:9.96051
 (:9.89892
is:9.89468
Text:9.59794
func:9.57941
function:9.39411

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(pred

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(pred
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pred>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "pred"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  pred
Nature of error: Variable pred is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: pred
LSP: Generating Completions for prefix: pred
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "icate"
root ::= completions

Top 20 Logits:
icate:27.9104
inate:13.111
licate:12.8805
ic:12.4608
ificate:12.4276
c:12.2987
acle:11.3171
ica:10.5465
iate:10.4756
ice:10.1522
ec:9.94956
iction:9.69558
icane:9.63678
cipe:9.55306
icator:9.42645
atype:9.42119
imate:9.34054
acent:9.25641
uce:9.25005
ate:9.23656
cite:9.08478

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(pred
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Unknown TypeHole), Bool)); (List (Unknown TypeHole))]);
           syn = (Arrow ((Var "Widget"), Bool))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  predicate
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (Widget -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Var "Widget"), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Var "Widget"), Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:20.0792
,[:13.1515
(:12.9617
 ,:12.8012
([:11.469
 widget:11.2772
,(:10.917
 (:10.4293
):10.4286
)(:10.3347
 [:10.2452
(),:10.0407

:9.9055
,,:9.67791
[:9.5538
 :9.35152
 Widget:9.05286
::8.90641
((:8.72941
 ([:8.55711
)[:8.54212

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Widget -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Widget -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "attributes" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "predicate" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "widget" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 widget:17.5171
 [:17.4815
 find:15.0984
 (:13.4932
 List:12.5173
 ([:12.1968
 attributes:12.1003
 [(:12.0905
 container:11.9654
 [[:11.914
 Container:11.8122
[:11.663
 {:11.5936
 :11.5376
 []:11.2082
 Widget:10.7948
 Text:10.524
 [{:10.3944
 list:10.356
 w:10.3357
 if:10.1607

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown TypeHole));
           syn =
           (Rec ("\206\177",
              (Sum
                 [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                   ("Column",
                    (Some (Prod
                             [(List (Var "\206\177"));
                               (List (Var "Attribute"))])));
                   ("Row",
                    (Some (Prod
                             [(List (Var "\206\177"));
                               (List (Var "Attribute"))])));
                   ("Container",
                    (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                   ])
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow ((Var "Widget"), Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: attributes [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan attributes bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi predicate sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  widget widget ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):18.3393
s:16.5063
:::16.0899
 @:14.488
 :::14.2307
 ):13.3563
,:12.8799
::12.4416
@:12.1574
 ::12.0365
.:10.9862
),:10.4108
)[:10.3322

:10.3168
[@:10.0345
:@:9.91031
 +:9.90852
)):9.75456
]:9.65252
_:9.64237
);:9.62766

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 @:20.8285
 :::14.1142
@:13.3604
 ++:13.288
 :13.1612
 &:12.7527
:::12.7027
 +:12.6668

:12.3795
 ::11.3264
 |:10.2699
  :10.0433
 #:10.0298
 *:9.85239
 <:9.79617
 (@:9.7306
 ->:9.71799
 [:9.68263
 end:9.67485
 ^:9.66246
 //:9.64108

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Row" | "Text" | "[" | "[]" | "case " | "find_all_widgets_of_type" | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
 find:18.8451
 List:15.8922
 [:14.6869
 (:13.3338
 :12.3549
find:11.3869
List:11.2392
[:11.1248

:10.8449
 if:10.7846
 list:10.5401
 ([:10.101
 []:9.48466
 [[:9.42765
  :9.41216
 @:9.00742
 Find:8.90985
 match:8.68392
 [(:8.51459
 get:8.41747
 {:8.0993

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}  
Error in term:
  find
Nature of error: Variable find is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find
LSP: Generating Completions for prefix: find
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_all_widgets_of_type"
root ::= completions

Top 20 Logits:
_:21.3373
all:15.1032
All:14.3223
 all:10.8723
(:10.7521
Widget:9.20678

:9.14192
er:9.10764
([:8.97949
__:8.91323
-:8.81788
ALL:8.41281
[:8.33758
a:8.24655
_(:8.0996
.:7.97016
l:7.83876
al:7.80524
\_:7.78669
t:7.25318
n:7.22741

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_
Nature of error: Variable find_ is not bound  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_
LSP: Generating Completions for prefix: find_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "all_widgets_of_type"
root ::= completions

Top 20 Logits:
all:24.4964
text:12.2431
widget:12.237
attribute:11.7256
attr:11.589
 all:11.5843
al:11.5297
find:11.4171
some:11.3765
any:11.1353
a:11.083
columns:11.0475
align:10.9249
attributes:10.6355
column:10.5663
container:10.521
if:10.4798
in:10.4383
list:10.352
contains:10.3117
allo:10.2457

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}  
Error in term:
  find_all
Nature of error: Variable find_all is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all
LSP: Generating Completions for prefix: find_all
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_widgets_of_type"
root ::= completions

Top 20 Logits:
_:22.5155
(:9.96549

:8.62784
\_:8.17722
-:8.06306
 _:7.97857
__:7.97205
.:7.71309
2:7.53437
 (:7.25988
___:6.8994
[:6.83734
(":6.55573
([:6.45885
 :6.24497
 flex:6.19408
1:6.10206
layout:6.04931
_(:6.04814
,:5.87034
::5.79421

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_
Nature of error: Variable find_all_ is not bound  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_
LSP: Generating Completions for prefix: find_all_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "widgets_of_type"
root ::= completions

Top 20 Logits:
widget:24.0013
wig:14.8957
Widget:14.6657
text:14.3162
container:13.8452
cont:13.7144
attributes:13.5833
attribute:13.2784
sub:13.1774
attr:13.0082
of:12.7629
wid:12.232
list:12.1405
 widget:12.024
w:11.9167
align:11.9153
elements:11.7754
display:11.7159
p:11.3221
l:11.1401
top:11.1142

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widget"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  find_all_widget
Nature of error: Variable find_all_widget is not bound  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widget
LSP: Generating Completions for prefix: find_all_widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s_of_type"
root ::= completions

Top 20 Logits:
s:24.076
(:13.3783
_:12.7504
t:11.0074
S:10.6584
d:10.4239
 (:9.76585

:9.61784
f:9.02618
 s:8.71537
=:8.67191
4:8.40125
 :8.34718
():8.19404
es:8.1257
ss:8.02
::7.97849
.:7.90192
z:7.6805
-:7.60297
':7.58255

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets
Nature of error: Variable find_all_widgets is not bound  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets
LSP: Generating Completions for prefix: find_all_widgets
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_of_type"
root ::= completions

Top 20 Logits:
_:23.6997
(:13.8467

:11.0654
Of:10.7177
([:10.6247
[:10.556
 of:10.4235
 (:9.86235
\_:9.73393
():9.57009
 :9.29065
.:9.14808
-:9.11259
of:9.03579
_(:8.69673
,:8.27052
((:8.13481
__:8.10326
 =:8.10123
\:8.05475
::7.83405

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets_
Nature of error: Variable find_all_widgets_ is not bound  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_
LSP: Generating Completions for prefix: find_all_widgets_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "of_type"
root ::= completions

Top 20 Logits:
of:26.0938
Of:13.8095
o:13.7016
to:13.4927
0:11.8124
OF:11.6898
in:11.5173
or:11.2897
 of:11.127
over:10.6812
left:10.6146
only:10.5384
t:10.2636
for:10.2303
top:10.2215
off:10.1736
cont:10.073
into:9.94569
at:9.89092
with:9.83225
transform:9.82273

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets_of
Nature of error: Variable find_all_widgets_of is not bound  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of
LSP: Generating Completions for prefix: find_all_widgets_of
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_type"
root ::= completions

Top 20 Logits:
_:22.4681
(:12.0841
([:9.48105

:9.4236
_(:8.76733
 (:8.54206
((:8.52051
__:8.29748
-:8.10759
 Column:8.09883
():8.0365
[:7.69707
2:7.50053
 row:7.4183
(":7.24687
Column:7.22478
(_:7.16357
({:7.15565
_*:7.13766
 :7.12499
1:7.12086

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "find_all_widgets_of_"))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}  
Error in term:
  find_all_widgets_of_
Nature of error: Variable find_all_widgets_of_ is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: find_all_widgets_of_
LSP: Generating Completions for prefix: find_all_widgets_of_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "type"
root ::= completions

Top 20 Logits:
type:27.3998
text:17.786
types:17.1322
te:16.2215
tree:14.7841
test:14.4961
ty:14.3035
typen:14.2906
table:14.0157
time:13.8519
typ:13.7474
 type:13.4236
term:13.3777
true:12.7039
tex:12.6581
template:12.5806
typename:12.393
t:12.2258
ite:12.1857
tip:11.9657
three:11.9418

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find_all_widgets_of_type>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Widget"));
           syn =
           (Arrow ((Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]),
              (List (Var "Widget"))))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  find_all_widgets_of_type
Nature of error: Expecting type [Widget] but got inconsistent type ((Widget, (Widget -> Bool)) -> [Widget])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: find_all_widgets_of_type
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: find_all_widgets_of_type
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: ( |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:20.9186
([:15.5278
 (:15.4102
((:14.6521
():13.4

:12.6903
[:12.4033
 widget:11.8858
(*:11.6156
(@:11.2159
(?:10.9039
(":10.6436
({:10.3143
(_:10.2263
.(:10.2262
 [:9.8416
<:9.83165
widget:9.70395
 :9.68613
,:9.61876
_:9.60341

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget widget
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= [Widget]
  LSP: Convex: Target types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Row Text [ [] case  find_all_widgets_of_type if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Column" | "Container" | "List.fold_left" | "List.fold_right" | "Row" | "Text" | "case " | "if " | "let " | "type " | "widget"
root ::= new-tokens

Top 20 Logits:
widget:19.2687
Container:16.2272
w:13.2379
Widget:12.9301

:12.5837
 widget:12.4478
container:12.4078
find:12.2893
Text:11.5439
text:11.1641
attributes:10.934
List:10.6787
Column:10.325
wig:10.2833
 Container:10.2187
Row:10.1698
row:9.93983
Cont:9.93243
wid:9.38909
 :9.20344
pred:9.19339

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <widget>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))]);
           syn =
           (Rec ("\206\177",
              (Sum
                 [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
                   ("Column",
                    (Some (Prod
                             [(List (Var "\206\177"));
                               (List (Var "Attribute"))])));
                   ("Row",
                    (Some (Prod
                             [(List (Var "\206\177"));
                               (List (Var "Attribute"))])));
                   ("Container",
                    (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
                   ])
              ))})))
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}  
Error in term:
  widget
Nature of error: Expecting type (Widget, (Widget -> Bool)) but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: widget
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
        ("Column",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Row",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Container",
         (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
        ])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: widget
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Rec ("\206\177",
   (Sum
      [("Text", (Some (Prod [String; (List (Var "Attribute"))])));
        ("Column",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Row",
         (Some (Prod [(List (Var "\206\177")); (List (Var "Attribute"))])));
        ("Container",
         (Some (Prod [(Var "\206\177"); (List (Var "Attribute"))])))
        ])
   ))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:18.8751
 ,:14.0832
):13.68
,[:13.0154
s:12.3514
)[:11.943
),:11.4478
 attributes:11.201
[:10.4778
::10.3488

:10.0043
)(:9.34546
.:9.32875
(),:9.28769
,,:9.21286
)):9.10852
 ::9.07725
 [:9.00974
 [],:9.00368
,(:8.92618
 :8.91359

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget,

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget,
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Seft type: (Widget, (Widget -> Bool))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: predicate ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  predicate type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))} <= (Widget, (Widget -> Bool))
  LSP: Convex: Target types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Column Container List.fold_left List.fold_right Row Text case  if  let  type  widget widget
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "predicate" | "type "
root ::= new-tokens

Top 20 Logits:
 predicate:18.9901
pred:13.9355
 :13.0231
 pred:12.1378
 [:11.3967
 attributes:11.3055
 fun:10.7358
 attribute:10.5605

:10.0837
 (:9.96722
 prede:9.92727
 f:9.6998
 prediction:9.67944
 Pred:9.54696
 predict:9.48532
 find:9.25195
 true:9.0437
 text:9.02766
 function:8.97917
 widget:8.94932
 if:8.64935

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <predicate>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Widget -> Bool)
  LSP: Info: Seft type: (Widget -> Bool)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Widget, (Widget -> Bool))
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: predicate
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Widget -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: predicate
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (Widget, (Widget -> Bool)), rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Rec ("\206\177",
   (Sum
      [("Text",
        (Some (Prod
                 [String;
                   (List
                      (Sum
                         [("Padding", (Some Int)); ("Margin", (Some Int));
                           ("Alignment",
                            (Some (Sum
                                     [("Start", None); ("Center", None);
                                       ("End", None)])));
                           ("Color", (Some String))]))
                   ])));
        ("Column",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Row",
         (Some (Prod
                  [(List (Var "\206\177"));
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])));
        ("Container",
         (Some (Prod
                  [(Var "\206\177");
                    (List
                       (Sum
                          [("Padding", (Some Int)); ("Margin", (Some Int));
                            ("Alignment",
                             (Some (Sum
                                      [("Start", None); ("Center", None);
                                        ("End", None)])));
                            ("Color", (Some String))]))
                    ])))
        ])
   )) (Arrow (
   (Rec ("\206\177",
      (Sum
         [("Text",
           (Some (Prod
                    [String;
                      (List
                         (Sum
                            [("Padding", (Some Int)); ("Margin", (Some Int));
                              ("Alignment",
                               (Some (Sum
                                        [("Start", None); ("Center", None);
                                          ("End", None)])));
                              ("Color", (Some String))]))
                      ])));
           ("Column",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Row",
            (Some (Prod
                     [(List (Var "\206\177"));
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])));
           ("Container",
            (Some (Prod
                     [(Var "\206\177");
                       (List
                          (Sum
                             [("Padding", (Some Int));
                               ("Margin", (Some Int));
                               ("Alignment",
                                (Some (Sum
                                         [("Start", None); ("Center", None);
                                           ("End", None)])));
                               ("Color", (Some String))]))
                       ])))
           ])
      )),
   Bool))
LSP: commas: self syn is (Prod [(Var "Widget"); (Arrow ((Var "Widget"), Bool))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (Widget -> Bool)
  LSP: Convex: Target types: (Widget -> Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: predicate ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  predicate type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
):19.8121
),:15.537
)[:14.4338
 ):14.4087
);:13.7267

:13.671
)):13.4788
)]:12.7715
,:12.2193
 :12.078
 end:11.9262
)(:11.6723
)::11.491
 @:11.271
).:11.0215
[:10.9285
 ,:10.8629
 ::10.7787
[@:10.5344
::10.4643
  :10.1456

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.8605
 :17.0336
 @:16.3651
 end:15.3302
  :14.2966
 in:13.728
    :13.537
   :13.3856
 &:12.994
            :12.8783
 ,:12.7124
@:12.637
                :12.4267
 ++:12.3873
 +:12.3859
        :12.3856
 #:12.1573
     :11.9899
 //:11.7852
 [:11.7534
       :11.6805

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :18.3954
in:16.9573
   :16.1223
end:15.5272
           :14.6158
        :13.9951

:13.9591
            :13.5045
 in:12.6928
    :12.6045
      :12.5701
               :12.5353
                :12.3459
     :12.0046
         :11.3939
 :11.376
          :10.9377
  :10.8039
and:10.7875
using:10.2525
             :10.1937

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
       

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
       
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {attributes: [Attribute], widget: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: [Widget]
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: [Widget], rec α.{(Text((String, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Column(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Row(([α], [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])) + Container((α, [(Padding(Int) + Margin(Int) + Alignment((Start + Center + End)) + Color(String))])))}
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:20.9813
 in:16.8675
 #:12.3817
 return:12.2989
 if:12.1075
 match:12.0501
 }:11.8985
 with:11.8723
 let:11.4898
 ;:11.3634
 |:11.2937
 //:11.1442
 case:11.1201
 var:10.8354
 es:10.7762
 else:10.7403
 of:10.6558
 where:10.6172
 (*:10.5205
 ::10.5018
 ):10.4563

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:18.0454
 :14.9548
    :13.7164
 in:13.6244
  :13.3628
        :13.3308
   :12.7311
            :12.2049
;:12.0926
                :11.5782
     :11.4341
      :11.2576
 end:10.8364
 if:10.7474
       :10.2605
         :10.0963
 @:10.0655
          :9.89711
	:9.62881
             :9.47717
           :9.23085

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Widget]
  LSP: Info: Seft type: [Widget]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {predicate: (Widget -> Bool), widget: Widget, find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Widget]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Widget, (Widget -> Bool)) -> [Widget])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
in:21.0327
   :16.8702

:15.5951
        :15.3181
    :14.9201
       :14.5051
end:14.4675
            :13.9213
 in:13.8345
 :13.4241
#:13.3314
  :12.8298
     :12.7116
                :12.6866
           :12.4202
      :12.3572
let:12.3276
and:12.2854
               :11.4558
         :11.4427
          :11.2001

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
in

LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
in
LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.3511
 :14.0529
    :12.0675
  :11.3165
        :10.9147
   :10.8922
                :10.2298
     :10.0554
            :9.85359
      :9.48805
         :8.90387
       :8.75653
          :8.65925
 let:8.42085
 {:8.24971
             :8.08487
 find:8.00749
 (:7.90964
	:7.8651
 Widget:7.82047
;:7.7555

================
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
in


LSP: Command: Completions(Types)
LSP: New token mode: type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
in

LSP: Process zipper: Recieved string:
type AlignmentType =
    + Start
    + Center
    + End
in

type Attribute =
    + Padding(Int)
    + Margin(Int)
    + Alignment(AlignmentType)
    + Color(String)
in

type Widget =
    + Text(String, [Attribute])
    + Column([Widget], [Attribute])
    + Row([Widget], [Attribute])
    + Container(Widget, [Attribute])
in

let find_all_widgets_of_type: (Widget, Widget -> Bool) -> [Widget] =
    fun widget, predicate ->
        case widget
            | Text(text, attributes) => if predicate(Text(text, attributes) ) then [Text(text, attributes) ] else []
            | Column(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Column(widgets, attributes) ) then [Column(widgets, attributes) ] else []
            ]
            )
            | Row(widgets, attributes) => List.filter(predicate, widgets) @ List.fold_left(fun acc, w -> acc @ find_all_widgets_of_type(w, predicate) ,[ 
                if predicate(Row(widgets, attributes) ) then [Row(widgets, attributes) ] else []
            ]
            )
            | Container(widget, attributes) => List.filter(predicate, widget) @ find_all_widgets_of_type(widget, predicate)
        end
in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find_all_widgets_of_type: ((Widget, (Widget -> Bool)) -> [Widget]), Text: ((String, [Attribute]) -> Widget), Column: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Row: (([rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}], [Attribute]) -> Widget), Container: ((rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, [Attribute]) -> Widget), Widget:: rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}, Padding: (Int -> Attribute), Margin: (Int -> Attribute), Alignment: (AlignmentType -> Attribute), Color: (String -> Attribute), Attribute:: (Padding(Int) + Margin(Int) + Alignment(AlignmentType) + Color(String)), Start: AlignmentType, Center: AlignmentType, End: AlignmentType, AlignmentType:: (Start + Center + End), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Row(widgets, attributes)) then Row(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  fun (acc, w) ->
 acc @ find_all_widgets_of_type(w, predicate), if predicate(Column(widgets, attributes)) then Column(widgets, attributes) else 
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> [Widget]), [[Widget]])  
Error in term:
  widget
Nature of error: Expecting type [?] but got inconsistent type rec α.{(Text((String, [Attribute])) + Column(([α], [Attribute])) + Row(([α], [Attribute])) + Container((α, [Attribute])))}
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: find_all_widgets_of_type List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Text Column Row Container Padding Margin Alignment Color Start Center End Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs Alignment App Center Color Column Container End List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Margin Padding Reverse Row Start String.reverse String.starts_with String.transform Text Trim Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false find_all_widgets_of_type float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "Alignment" | "App" | "Center" | "Color" | "Column" | "Container" | "End" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Margin" | "Padding" | "Reverse" | "Row" | "Start" | "String.reverse" | "String.starts_with" | "String.transform" | "Text" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find_all_widgets_of_type" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.7673
let:16.6744
    :15.6608
        :15.3108
#:14.9592
 :14.2902
            :14.0693
   :13.6452
                :13.4311
  :12.9622
"":12.917
type:12.7903
*):12.7348
(*:12.6786
```:12.5519
":12.1477
|:12.1051
print:12.0985
     :12.055
       :12.0287
      :11.812
